{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":14962165765982767634,"abi":{"parameters":[{"name":"a","type":{"kind":"field"},"visibility":"private"},{"name":"b","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7P3djjS70m6H3ct3LBj8CUaQuhXDMGRLMgQIW4YlHwn73l2ftCqrpxf5smZ1TnIwus/etVDZfJ6c1WNkZxaj/vf/+O//h//H//f/9X//n/7L//i//K//8d/+X//3//if/5f/53/3v/1P/8t/efyv//0/wv/xf/2v/+//7r/85//6X/+3/+7/87/9x3/brPw3//E//Jf//j/+2xhC+K//zX/8j//T//w//Md/W/J//W/+7bUx1vx8cYr1enEMsfNqk+dPtpL+8tr/23/zHxGUJYGyZFAWAWUpoCwKymKgLBWUpZFYtxq8Ua8wMnltjDHI80fHmF8/W+X/yL4Y1DU9X1xz+LcTmUhhMimMkMIUUhglhTFSmEoK00BhUiCFWX2p3OQKk75pj7Qa2PX5k2vTWfZc9enJmFsoryCl8/JUW4z/evnj35L+/6vmn1NVfk7V8nOq6s+paj+nav05VduPqZrDz6kaf07Vn3O1lH/O1VKWn1P151wt5Z9ztZR/ztVS/jlXS/nnXC3Jz7lakp9ztSQ/52pJfs7VksjPqfpzrpbk51wtyc+5WpKfc7UkP+dqqfycq6Xyc66Wys+5Wio/52qpyM+p+nOulsrPuVoqP+dqqfycq6Xyc66W9OdcLenPuVrSn3O1pD/naknl51T9OVdL+nOulvTnXC3pz7la0p9ztWQ/52rJfs7Vkv2cqyX7OVdLJj+n6s+5WrKfc7VkP+dqyX7O1ZL9nKul+nOulurPuVqqP+dqqf6cq6UqP6fqz7laqj/naqn+nKul+nOulurPuVpqP+dqqf2cq6X2c66W2s+5WmriqWpJr6r2lxEYnSRSrijS8p9fbKX+67XWXoOcUv4/TqGrq7A9p9DV1d2eU+jqqnHPKXR1NbrnFLq6yt1yCh+n6Pccfvscurou33QOXV3wbzqHrv6S2HQO5fccfvsc/v6N8v1z+PtHyvfP4e9fKd8/h79/pnz/HP7+nfLtcxh//075/jn8/Tvl++fw9++U75/D379Tvn8O5fccfvsc/v6d8v1z+Pt3yvfP4e/fKd8/h79/p3z/HP7+nfLtc5h+/075/jn8/Tvl++fw9++U75/D379Tvn8O5fccfvsc/v6d8v1z+Pt3yvfP4e/fKd8/hz/375TyiqKi3zmHjv5OaWLteQ6btPL1tPxnV09f+TPt6ui6v9VyfRK+VbV/6+ro+nza1dF19LSr/KCujq5Lp10dXT9Ouzq6zpt2dXQ9Nu3q6bpp0tXTl/9Mu/6g6yZPX/8z7fqDrps8fQHQtOsPum7y9BVA064/6LrJ05cATbv+oOsmT18DNO36g66bPH0R0LTrD7pu8vRVQNOuP+i6ydOXAU27/qDrJk9fBzTt+oOumzx9IdC06w+6bvL0lUDTrj/ousnTlwJNu/6g6yZPXws07fqDrps8fTHQtOsPum7y9NVA064/6LrJ05cDTbv+oOsmT18PNO36g66bPH1B0LTrD7pu8vQVQdOuP+i6ydOXBE27/qDrJk9fEzTt+oOumzx9UdC06w+6bvL0VUHTrj/ousnTlwVNu/6g6yZPXxc07fqDrps8fWHQtOsPum7y9JVB064/6LrJ05fwTLv+oOsmT19rM+36c66bkqfviZl2/TnXTcnT965Mu/6c66YU5Ad1/TnXTcnT94JMu/6c66bk6Xs2pl1/0HWTp++tmHb9QddNnr4HYtr1B103efpehWnXH3Td5Ol7CqZdf9B1k6e5/9OuP+i6ydMc/WnXH3Td5Gku/bTrD7pu8jTnfdr1B103eZqbPu36g66bPM0hn3b9QddNjuaF5xDDc17449+p/FtXP9dNs64x/F+y9v+uizEGea4UH+t2D62fH9o+PrR/Ef/eofHzQ9Pnh+bPD5XPDy2fH6qfH/r5uyl9/m7qszhbug79z3933/59tL13aPz80PT5ofnzQ+XzQ8vnh+rnh9rnh9bPD/383SSfv5vk83eTfP5uks/fTfL5u0k+fzfJ5+8m+fzdJJ+/m+Tzd1P5/N1UPn83lc/fTeXzd1P5/N1UPn83lc/fTeXzd1P5/N1UPn836efvJv383aSfv5v083eTfv5u0s/fTfr5u0k/fzfp5+8m/fzdZJ+/m+zzd5N9/m6yz99N9vm7yT5/N9nn7yb7/N1kn7+b7PN3U/383VQ/fzfVz99N9fN3U/383VQ/fzfVz99N9fN3U/383VQ/fze1z99N7fN3U/v83dQ+fze1z99N7fN3U/v83dRG76aSX4da6x5aPz+0fXqohfD5ofHzQwfvppzCdWiupXto/vxQ+fzQ8vmh+vmhg3eTpHQdKmLdQ+vnh7aPD43h80Pj54cO3hJFX4eW/hmO8vmh5fND9fND7eND0+CX7mHP69CHIrqH5s8P7XetUa+b9zVW6R5qnx9aPz+0fXzo4HbrW4f23/41SbkOTabdQ9Pnh+bPD5XPDy2fH6qfH2qfH1o/P3Twbsrxov/j393fnMHt1rcOjZ8fmj4/NH9+6ODdlHN9HVq69B/cbn3rUP38UPv80Pr5oe3jQ0v+/NDBaZLX9XCV1H37D+4jVilfDtXcPbR+fmj7+NDBfcQq7XWaSuyepsF9xLcOTZ8fmj8/VD4/tIwOzV8Ord1D9fND7fND6+eHto8PtfD5oYN3U5HXe7iU1D108G4qRV+HWn/V/Pmh8vmh5Y2ug0P180Pt80Pr54e2jw8d3Ed869D4+aHp80NH7yb58vavXQ5X+fzQ8vmh+vmhg3eTxtehmrp3Qwb3Ef96aO76dXAfseqXX7rHHf7eoYP7iI9Dw/TQ+Pmhg3fT42bqdejj7+Ovh3Y+KdbS9UGxJq+3XqmvdfKidWTROmXROrpoHVu0Tl20TrthnZTK8y5OSl9+f17r1BAWrRMXrZMWrZMXrSOL1imL1tFF69iideqidRbxIC7iQVzEg3g7D2rsrpMXrSOL1imL1tFF69iideqiddqadVJYtE5ctM4iHqRFPEiLeJAW8SAt4kFaxIO0iAdpEQ/yIh7kRTzIi3iQF/EgL+JBXsSDvIgHeREP8iIe5EU8kEU8kEU8kEX3D2TR/QNZdP9AFt0/kEX3D2TR/QNZdP9AFt0/KIvuH5RF9w/KIh6URTwoi3hQFvGgLOJBWcSDsogHZREPdBEPdBEPdBEPdBEPdBEPdBEPdBEPdBEPdBEPdBEPbBEPbBEPbBEPbBEPbBEPbBEPbBEPbBEPbBEPbBEP6iIe1EU8qIt4UBfxoC7iQV3Eg9En8qy81mlZ/ryOlnJ9VP0//93bHlVHH+D7B1aqy1Zqq1YafZrwH1gpLlspLVspL1tJlq1Ulq20jBFtGSPaMka0VYxoISxbKS5bKS1bKS9bSZatVJatpMtWsmUr1WUrLWNEXMaIuIwRcRkj4jJGxGWMiMsYEZcxIi5jRFzGiLiMEWkZI9IyRqRljEjLGJGWMSItY0Raxoi0jBFpGSPSMkbkZYzIyxiRlzEiL2NEXsaIvIwReRkj8jJG5GWMyMsYIcsYIcsYIcsYIcsYIcsYIcsYIcsYIcsYIcsYIcsYUZYxoixjRFnGiLKMEWUZI8oyRpRljCjLGFGWMaIsY4QuY4QuY4QuY4QuY4QuY4QuY4QuY4QuY4QuY4QuY4QtY4QtY4QtY4QtY4QtY4QtY4QtY4QtY4QtY4QtY0Rdxoh607s8f1kpt+5KZdlKN70jrF0r9ef1tbs+VTdf6a5P1b2xUly2Ulq20j3WUA2vlVr588vTI8u/Xp1UXuNZXx9pbTd9BO/2WIUZS5mxjBmrMmM1YCwJN30g8fZYkRkrMWMRKf+IRaT8IxaR8o9YRMo/YhEp/4hFpPwjFpPykUn5yKR8ZFI+MikfmZSPTMpHJuUjk/KRSfnIpHxiUj4xKZ+YlE9Myicm5ROT8olJ+cSkfGJSPjEpn5mUz0zKZyblM5PymUn5zKR8ZlI+MymfmZTPTMoLk/LCpLwwKS9MyguT8sKkvDApL0zKC5PywqR8YVK+MClfmJQvTMoXJuULk/KFSfnCpHxhUr4wKa9MyiuT8sqkvDIpr0zKK5PyyqS8MimvTMork/LGpLwxKW9MyhuT8sakvDEpb0zKG5PyxqS8MSlfmZSvTMpXJuUrk/KVSfnKpHxlUr4yKV+ZlK9Myjcm5RuT8o1JeeTe10csJuWRe18fsZiUR+59lbhj22QOsTx/eEjSjZWYsTa85XOU/Pzh0Wo3ljJjGTNWZcZqyFg7NgLmVJ6TS3Kyv3CrA7ncnj86SexCbseuwds7JAcdsoMO4qBDcdBBHXQwBx2qgw7t/A7JgaeTA08nB55ODjy9Y/vpNzq0boezPN3vcJan+x3O8nS/w1me7nc4y9PdDvksT/c7bPF0sleH/OcOsei/Xhu/vFRT56XVnt+m3sIrccq9nxrr9WNTyl9ffJ2Z9HtmBmcm/56ZwZmR3zMzODPl98wMzoz+npnBmbHfMzM4M/X3zAzOTPs9M/0zI+H3zAzOzO818OjM/F4Dj87M7zXw6MzI75kZnJnfa+DRmfm9Bh6dmd9r4NGZ+b0GHp2Z32vgwZkpx14DXw2OvVa9GtCvKVOIz5vmIXUb0K/95g3k+Ab0a6l5A/o1z7wB/dok5evxV47dBvRriHkDuuunDZTu5HkDOk215Osnl24DOk3nDei/yRafrzWVbgP6b7LV554aa9prYPTf5HkD+tX1vAH96nregH51PW9A98G8Ad0H8wb0q+t5A/rV9bwB3snTBsc7uZ7j5Bq6V3aV7+TnJzJrCt0GfCfPGuCdbDppQHdyzdfvgfR/k+lOnjegO3negO7keQO6k+cN6E6eNmh0J88b0J08b0B38rwB3cnzBgc5uX/XsfGdfF3ZWfe6qPGdPGvAd/KsAd/JswZ8J/+5QQp8J88a8J08a8B38qwB3slJJw3wTp42wDt52mCLk+vVIEf9c4Oc8+vFIl9ffHUwBx2qgw7t/A575tbd3CE66JAcdMjwDimV5yeeH1LpdxAHHYqDDnRPv9OB7ul3OtA9/U4Huqff6JDonn6nA93T73Sge/qdDg48vWdu3c0dHHg6OfB0OsrTNXY7HOXpQYejPN3vkI/y9KDDUZ4edDjK04MOR3l60OEoTw86HOXpQYejPD3o4MDT2YGnswNPiwNPiwNPiwNPiwNP75ksdXMHB54WB54WB54WB54WB54uDjxdHHi6OPB0ceDpPdOFbu7gwNPFgaeLg+fTxcHz6eLg+bQ6eD6tDp5Pq4Pn0+rg+fSeuVU3d3DwfFodPJ9WB55WB55WB542B542B542B542B57eM0/s5g4OPG0OPG0OPG0OPG0OPF0deLo68HR14OnqwNN7Zozd3MGBp6sDT1cHnq4OPF0deLo58HRz4OnmwNPNgaf3zB27uYMDTzcHnm4OPN0ceLqd7+kczvd03jKFbDr2I28ZLfZGrMyMJcxY/7jzrpV02Uq2bKW6bKW2aqV/fjLUtVJcttI9qLL8+sYsK3nyyxf0Odnw8c8vscIrVmbGEmaswoylzFjGjFWZsRoy1k3Tf26PFZmxmJRPTMonJuUTk/KJSfnEpHxiUj4xKZ+ZlM9Mymcm5TOT8plJ+cykfGZSPjMpn5mUz0zKC5PywqS8MCkvTMoLk/LCpLwwKS9MyguT8sKkfGFSvjApX5iUL0zKFyblC5PyhUn5wqR8YVK+MCmvTMork/LKpLwyKa9MyiuT8sqkvDIpr0zKK5PyxqS8MSlvTMobk/LGpLwxKW9MyhuT8sakvDEpX5mUr0zKVyblK5PylUn5yqR8ZVK+MilfmZSvTMo3JuUbk/KNSfnGpHxjUr4xKd+YlG9Myjcm5RuS8hKQlJeApLwEJOUlICkvAUl5CUjKS0BSXgKS8hKQlJfApHxkUj4yKc/c+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vsmXbZIzP7xnKMYdurMSMteMtn0p8/vBUUzeWMmMZM1ZlxmrEWOWf3wh4rRSXrXQTXWq6Vqqh/PnlJYX2r1eXFEP3VGdmLGHGKhtilaDPWEXy11j//uKU29MnSeLrl+v1nZHlrr19WzuYgw7VQYd2foe79iNu7RAddEgOOmQHHcRBBweejg48HR14OjrwdDzL063XIZ3l6X6Hszzd73CWp/sdzvJ0v8NZnu53OMvT/Q67Pa1/6XDF2q3eQawdNhUNVyyTyX/xVJ4/OqUvL/76X7yd3yEHBx2igw7JQYfsoIM46FAcdFAHHcxBBweezg48LQ48LQ48LQ48LQ48fdd+8a0dHHhaHHhaHHhaHHhaHHi6OPB0ceDp4sDTxYGn79rxv7WDA08XB54uDjxdHHi6OPC0OvC0OvC0OvC0OvD0XTMbtnZw4Gl14Gl14Gl14Gl14Glz4Glz4Glz4Glz4Om7pm5s7eDA0+bA0+bA0+bA0+bA09WBp6sDT1cHnq4OPH3X3JStHRx4ujrwdHXg6erA09WBp5sDTzcHnm4OPN0ceLo58HRz4OnmwNPNgaebA0+38z2t4XxPazjf0xrO97SG8z2t4XxPazjf0xrO97SG8z2t4XxPa3Dg6ejA09GBp6MDT0cHnt4yNezuDg48HR14OjrwdHTg6ejA08mBp5MDTycHnk4OPL1latjdHRx4OjnwdHLgaQfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjUwfzyNTBPDJ1MI9MHcwjMwfzyMzBPDJzMI/MHMwjs3C+p83BPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjMwfzyMzBPDJzMI/MHMwjqw7mkVUH88iqg3lk1cE8shrO93R1MI+sOphHVh3MI6sO5pFVB/PIqoN5ZNXBPLLqYB5ZdTCPrDqYR1YdzCOrDuaRVQfzyKqDeWTVwTyy6mAeWXUwj6w6mEdWHcwjqw7mkVUH88iqg3lk1cE8supgHll1MI+sOphHVrfMkCrt+cOL5vK1wxWrMGPt+M2r5fov3mLoxmrIWFvmAL0RKzJjJWasf/wC8lpJlq1Ulq2ky1ayZSvVZSu1VSv986NQrpXispXSspVuYYQGK8+VNIb455dni/H5wy2mHrrumedxf6zCjKXMWMaMVZmxGjLWPRMs7o8VmbESMxaT8sqkvDIpr0zKK5PyyqS8MilvTMobk/LGpLwxKW9MyhuT8sakvDEpb0zKG5PylUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSfnKpHxjUr4xKd+YlG9Myjcm5RuT8o1J+cakfGNSviEp3wKS8i0gKd8CkvItICnfApLyLSAp3wKS8i0gKd8CkvItMCkfmZSPTMpHJuUjk/KRSfnIpHxkUj4yKR+ZlI9Myicm5dMOQNSYrh+e+7EKM9aOt3yV64e3WrqxGjJWDsxYkRkrMWP94xc210qybKV76JLs+uj149+5u5IuW8mWrVSXrdRWrXTPXqi3VorLVkrLVsrLVpJlKy1jhCxjhCxjhCxjhCxjRFnGiLKMEWUZI8oyRpRljCjLGFGWMaIsY0RZxoiyjBG6jBG6jBG6jBG6jBG6jBG6jBG6jBG6jBG6jBG6jBG2jBG2jBG2jBG2jBG2jBG2jBG2jBG2jBG2jBG2jBF1GSPqMkbUZYyoyxhRlzGiLmNEXcaIuowRdRkj6jJGtGWMaMsY0ZYxoi1jRFvGiLaMEW0ZI9oyRrRljGiLGFFCCMtWistWSstWuocR2eRaKVvpriTLVirLVtJlK9myleqyldqqlW76/Ok7K8VlK6VlKy1jRFzGiLiMEXEZI+IyRsRljIjLGJGWMSItY0Raxoi0jBFpGSPSMkakZYxIyxiRljEiLWNEXsaIvIwReRkj8jJG5GWMyMsYkZcxIi9jRF7GiLyMEbKMEbKMEbKMEbKMEbKMEbKMEbKMEbKMEbKMEbKMEWUZI8oyRpRljCjLGFGWMaIsY0RZxoiyjBFlGSPKMkboMkboMkboMkboMkboMkboMkboMkboMkboMkboMkbc9ElBCflaSYJ0V5JVK930ubCirz2SxUJ3pbhspXvOXgvxWqlJ93nuTZ+hemclXbaSLVupLlvpFkZYuKYfPP5d9M8vzw9XPX/4QyavF4cr1j0fuLo/VmTGSsxYmRlLmLEKM5YyYxkzVmXGQlI+BiTlY0BSPgYk5WNAUj4GJOVjQFI+BiTlY0BSPgYk5WNgUj4yKR+ZlI9Mykcm5SOT8pFJ+cikfGRSPjIpH5mUT0zKJyblE5PyiUn5xKR8YlI+MSmfmJRPTMonJuUzk/KZSfnMpHxmUj4zKZ+ZlM9Mymcm5TOT8plJeWFSXpiUFyblhUl5YVJemJQXJuWFSXlhUl6YlC9Myhcm5QuT8oVJ+cKkfGFSvjApX5iUL0zKFybllUl5ZVJemZRXJuWVSXllUl6ZlFcm5ZVJeWVS3piUNybljUl5Y1LemJQ3JuWNSXljUt6YlDcm5SuT8pVJ+cqkfGVSvjIpX5mUr0zKVyblK5PyzL2vkbn3NTL3vkbm3tfI3PsamXtfI3Pva2TufY3Mva+Rufc1Mve+Jube18Tc+5qYe18Tc+9rCkjKJ+be18Tc+5qYe18Tc+9rYu59Tcy9r2nLtskYw/OHxxy6sQoz1o63fCrPV+dUUzdWQ8bashHwjViRGSsxY/3jFzbXSrJspZvo0l4rxfB9Ft+1Xe/uWMaMVZmxGjLWXdv17o4VmbESM1ZmxhJmLCblM5PymUn5zKR8ZlJemJQXJuWFSXlhUl6YlBcm5YVJeWFSXpiUFyblC5PyhUn5wqR8YVK+MClfmJQvTMoXJuULk/KFSXllUl6ZlFcm5ZVJeWVSXpmUVybllUl5ZVJemZQ3JuWNSXljUt6YlDcm5Y1JeWNS3piUNybljUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSfnKpHxlUr4xKd+YlG9Myjcm5RuT8o1J+cakfGNSvjEp35CUzwFJ+RyQlM8BSfkckJTPAUn5HJCUzwFJ+RyQlM8BSfkcmJSPTMpHJuUjk/KRSfnIpHxkUj4yKR+ZlI9Mykcm5ROT8olJ+cSkfGJSPjEpz9z7mpl7XzNz72tm7n3NzL2vmbn3NTP3vmbm3tfM3PuamXtfM3Pva2bufc3Mva+Zufc1M/e+Zube18zc+5qZe18zc+9rZu59zcy9r5m59zVv2TY5nSmWt2ybfCPWjrf8dBxV3rIR8I1YyoxlzFiVGesfv7B5rvTP7+27VrqHLjHrayWtf365aMn/erVorb1TfdN2vdtjZWYsYcYq62M9bPX0/OOfXc/ftF3v9ljGjFWZsRoy1k3b9W6PFZmxEjNWZsYSZiwm5Y1JeWNS3piUNyblK5PylUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSfnGpHxjUr4xKd+YlG9Myjcm5RuT8o1J+cakfENSXgKS8hKQlJeApLwEJOUlICkvAUl5CUjKS0BSXgKS8hKYlI9Mykcm5SOT8pFJ+cikfGRSPjIpH5mUj0zKRyblE5PyiUn5xKR8YlI+MSmfmJRPTMonJuUTk/KJSfnMpHxmUj4zKZ+ZlM9Mymcm5TOT8plJ+cykfGZSXpiUFyblhUl5YVJemJQXJuWFSXlhUl6YlBcm5QuT8oVJ+cKkfGFSvjApX5iUL0zKFyblC5PyhUl5ZVJemZRXJuWVSXllUp6591WYe1+FufdVmHtfhbn3VZh7X4W591WYe1+FufdVmHtfhbn3VZh7X4W591WYe1+FufdVmHtfhbn3VZh7X4W591WYe1+FufdVmHtfZc/eVw1XLI3dWJUZqyFj7dn7Oo+1hfJNr1jNurESM1ZmxhJmrB2AkHS95SX33/KNGKts2QiotTxjWWjdWJkZS5ixCjOWMmMZM1ZlxmrIWFs2Ar4R6x+/sLlWSstWystWkmUrlWUr6bKVbNlKddlKbdVK//yes2ulmxhh7VopfaVR7+XVwnOEdLWUe+i6axvZ3bEyM5YwYxVmLGXGMmasyozVkLHyBkBIvH64ROvHEmasDW/5x12I53WzpO63kJRcmbEaMtZde2rujhWZsdKO38SWX7H+cuft31+csjyTpFxev7alvjpkBx0E38HK1aGGbofioIM66GD4Du156z1JTN0O1UGHdn6HEhx0iA468D0978D39LwD39PzDnxPzzvwPT3v4MDTxYGniwNP61mebt0OZ3m63+EsT/c7nOXpfoezPN3vcJan+x12ePpxk+XqYPp9tpqDDtVBh3Z+BwsOOkQHHZKDDtlBB3HQoTjo4MDT5sDT5sDTdpanu9et9SxP9zuc5el+h7M83e9wlqf7Hc7ydL/D7r+nrbcnq9QdyJfXJ0Ok/8mQ2pCxWmDGisxYiRlrBxHz6zdRbvjEThMHHQq+w/TTLk0ddDAHHSq+w/Qvl9aO76AhOOgQHXRIDjrwPT3vwPf0vAPf0/MOfE/PO/A9Pe9wvqc1OPB0dODpeJanW7fDWZ7udzjL0/0OZ3m63+EsT/c7nOXpfocdnpZruoHIX+/0fsbW6qBDO79DCg46RAcdkoMO2UEHcdChOOigDjo48HRy4OnkwNP5LE93r1vzWZ7udzjL0/0OZ3m63+EsT/c7nOXpfofdf09b/drhirX7VvYg1u670/1YsvtG5yDW7nuXg1i7b0cOYgkz1u6bhoNY0N/E3Y9++rHK7qc5g1hMbm2fBNL9JK5uH+4xiIX83LIW5hXElokUj6fqz1iPmxrdWA0Za8u8gsfv/xXLwt+5wu7+5b9lXsHdHcRBh+KggzroYA46VAcd2vkdtswruLtDdNDBgafNgae3zCu4u4MDT9tZnu7eGbazPN3vcJan+x3O8nS3Qz3L0/0OZ3m632GLp02uDrV+m61b5hXc3UEcdCgOOqiDDuagQ3XQoZ3fYcv4irs7RAcdHHi6OfD0likad3c4y9Pd69Z2lqf7Hc7ydL/DWZ7udzjL070OFs7ydL/D7r+na+8BvYXdt7IHsYQZ6x8HwrVSW7XSP7/1/VopLlspLVvpnsu+lO21ksq336g37d++PVZhxlJmLFsfK+bw1N7jn6UbqzJjNWSsm3Ys3x4rMmMlZqzMjCXMWIUZS5mxmJRPTMonJuUzk/KZSfnMpHxmUj4zKZ+ZlM9Mymcm5TOT8plJeWFSXpiUFyblhUl5YVJemJQXJuWFSXlhUl6YlC9Myhcm5QuT8oVJ+cKkfGFSvjApX5iUL0zKFybllUl5ZVJemZRXJuWVSXllUl6ZlFcm5ZVJeWVS3piUNybljUl5Y1LemJQ3JuWNSXljUt6YlDcm5SuT8pVJ+cqkfGVSvjIpX5mUr0zKVyblK5PylUn5xqR8Y1K+MSnfmJRvTMo3JuUbk/KNSfnGpHxDUr4GJOVrQFK+BiTla0BSvgYk5WtAUr4GJOVrQFK+BiTla2BSPjIpH5mUj0zKRyblI5PykUn5yKQ8c+9rZe59rcy9r5W597Uy975W5t7Xytz7Wpl7Xytz72tl7n2tzL2vlbn3tTL3vlbm3tfK3PtamXtfK3Pva2Xufa3Mva+Vufe1Mve+Vube17pn76uGK5bGXqw9e1/nsSIzVmLG2kL5plesZt1YwoxVmLEUGWvLtklJ11tecvctv2Xb5BuxdrzltZZnLPs6zvBLrMKMpcxYxoxVmbEaMtaWjYBvxIrMWIkZ6x+/sLlWkmUrlWUr6bKVbNlKddlKbdVKd+1muyabP/7d6p9fPh9tXu/azXZ3rMSMlZmxhBmrMGMpM5atj1VDe9r58U/t2fmu3Wx3x2rIWHUD5WtMz7/va5TajRWZsRIzVmbGEmaswoylzFjGjFWZsRoyVmNSvjEp35iUb0zKt92UL9173m035QexdlN+EGs35QexdlN+EGs35buxWthN+VK6sXZTfhBrN+UHsXZTfhBrO+X7sbZTvh9rO+X7sbZTvh9rC+UtX7Fq6sZqyFgxMGPtoHwK1/2tFLUbKzFjbaF8q69Y1o0lzFiFGUuZsYwZawflU7IrlrRurIaMlcLmWKVL+RSZsRIzVmbGEmaswoylzFjGjLWb8oNYuynfj5WZlM9Mymcm5TOT8plJ+cykfGZSPjMpn5mUz0zKC5PywqS8MCkvTMoLk/LCpLwwKS9MyguT8sK8Y1N2U34QazflB7F2U34QazflB7F2U34QazflB7F2U34QazflB7GY9+ULk/LKpLwyKa9MyiuT8sqkvDIpr0zKK5PyyqS8MilvTMobk/LGpLwxKW9MyhuT8sakvDEpb0zKG5PylUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSfnKpHxjUn7LtslUwxWrdveQbdk2OYulYcseMnlNzyhBu7ESM9aO/4gW4jOWpdyNpcxYxoxVmbEaMtaWXVFvxIrMWIkZKzNjCTMWk/KRSfl/fvvRtVJbtdI/v0noWikuWyktW+ke2uTcrpWy6p9fnkSeuR7/LL036k27c26PVZixlBnLmLEqM1ZDxrppd87tsSIzVmLGYlI+MymfmZTPTMpnJuUzk/KZSXlhUl6YlBcm5YVJeWFSXpiUFyblyw5AlPQcuPT4p3RjRWasf/wtf61Ulq2ky1ayZSvVZSvd5P2WrpUkhW//Wt/0Sf7bY0VmrMSMlZmxhBmrMGMpM5YxY1VmLCbljUl5Y1LemJQ3JuWNSXljUt6YlDcm5Y1JeWNSvjIpX5mUr0zK1x2AmN/QqIaM1Xa85cv1134qvW+DecSKzFiJGSszYwkz1j9+YXOtpMtW+vt0uQ6tnx/aPj00fvAlM9ehAzY0ja9DrX9o+vzQ/Pmh8vmh5fND9fND7fND6+eHto8PHX1s+51DP383xc/fTbESrwZibMhYKTBjRWasxIy15SJFX7G0dmMJM1ZhxlJmLGPGqsxYDRkrB2asyIy1hfIlvmL9ZT9y58VZnklSLq/NNKW+OmQHHQTfwcrVoYZuh+KggzroYPgOLVy3X2PqdqgOOrTzO0hw0CE66MD39LwD39PzDnxPzzvwPT3vwPf0vIMDT4sDT4sDT5ezPN26Hc7ydL/DWZ7udzjL0/0OZ3m63+EsT/c77Pa0dW97lS3qbdeHjjTkbqzKjNWQsbbsmXkjVmTG2mKmml6xZEaT6V3SLRts/l6H6d25Lbtx7u5QHHRQfIfpVf+WTUF3d6gOOrTzO2zZm3R3h+igA9/T8w58T8878D0978D39LyDA0+bA0+bA0/bWZ7u3lGpZ3m63+EsT/c7nOXpfoezPN3vcJan+x12ezp2bxnV3epN2o2126aDWJsfhWqybqwtzpttn4vMHaORuWM0MneMRuaO0cjcMRpbYcZSZixjxqrMWEjKp4CkfApIyqeApHwKSMqngKR8CkjKp4CkfApIyqeApHwKTMpHJuUjk/KRSfnIpHxkUj4yKR+ZlI9Mykcm5SOT8olJ+cSkfGJSPjEpn5iUT0zKJyblt3xx2nRiTMrIb8xIGfmNGWnLF6e9ESszY8mOWLOpHmnLF6e9EUuZsYwZqzJjNWSsLV+c9kasyIyVmLG2UP7WST5py7es3d2h4DvM9nekLd/fdncHc9Ch4jvMPjeapJ3fYc8XB97cITrokBx04Ht63oHv6XkHvqfnHfiennfge3rewYGniwNPqwNP61mebt0OZ3m63+EsT/c7nOXpfoezPN3vcJan+x12e7o7jSjpFvXOJsYkbchYFpixIjNWYsbaYqZbpxGluyYE/IMdpnfnrDjooA46GL7D9KrfqoMO7fwONTjoEB10SA468D0978D39LwD39PzDnxPzzs48HR14OnqwNPtLE9376i0szzd73CWp/sdzvJ0v8NZnu53OMvT/Q67Pd2dRpTabvV2x/6kttumg1ibH4X2pxHlsMV5s60rOURmrMSMlZmxhBmrMGMpM5YxY1VmrIaMFZmUj0zKRyblI5PykUn5yKR8ZFI+MikfmZSPTMonJuUTk/KJSfnEpHxiUj4xKZ+YlE9Myicm5ROT8plJ+cykfGZSPjMpn5mUz0zKZyblM5PyN80SSCZXrMe9/j+/vJb8HHHw+Kd0Ywkzlm2IZeH5uKBayt1YlRmrIWPdtMX79liRGYv5m3jTnt7bYykzljFjVWasHdwqlq5YrRtLAzNWZMZKzFiZGUuYsQozljJjGTNWZcZiUt6YlDcm5W075buf37LtlO/H2k75fqztlO/H2k75fqztlO/H2k75fqzNlNdQerFqYMaKzFiJGSszYwkzVmHG2kF5zddtN5XQjWXMWJUZawfl1V6xaurFaoEZawflVeUVq3unuSVmrMyMJcxYhRlLmbGMGasyYzViLAmBGQv5PFFCYsbKzFjCjFWYsZQZC/mpEQnIT41IQH5qRCLyUyMSmZSPTMpHJuXjdsprN9Z2yvdjbad8P9Z2yvdjbad8P9Z2yndjpe2U78faTvl+rO2U78faTvl+LCblE5PyiUn5xKR8YlI+MSmfmZTPTMpnJuUzk/KZSfnMpHxmUj4zKZ+ZlM9MyguT8sKkvDApL0zKC5PywqS8MCm/fzdnPxbzvjxzN6cwd3MKczenFOZ9+cK8L1+2U74fi/n0tTCfvhbm09fCpHxhUl6ZlFcm5ZVJeWVSXpmUVybllUl5ZVJemZRXJuWNSXljUt6YlDcm5Y1JeWNS3piUNybljUl5Y1K+MilfmZSvTMpXJuUrk/KVSfnKpHxlUr4yKV+ZlN+ymzPV57e2Pf4Zu7EyM5YwYxVmLGXG2sGtHMszVs7WjVWZsRoxVtmym/ONWJEZKzFjZWYsYcYqzFjKjIWkfAlIypfApHxkUj7upnx3vE6Juyk/iLWb8oNYuyk/iLWb8oNYuyk/iLWb8oNYuynf/RaREndTvh8r7ab8INZ2yvdjbad8P9Z2yvdjbad8P9YWytt1ayRb68ZSZixjxtpBeQn6jCWxe3W6ZTfnPNaW3Zy5tVes7m/ilt2cb8RKzFiZGUuYsQozljJjGTNWZcZqyFhbdnNKvsZHS5FurMiMlZixMjOWMGMVZixlxjJmrMqM1ZCxCpPyhUn5wqR82U757t+JZTvl+7G2U74fazvl+7G2U74fazvl+7G2U74bS7dTvh9rO+X7sbZTvh+LSXllUl6ZlFcm5ZVJeWVSXpmUNybljUl5Y1LemJQ3JuWNSXljUt6YlDcm5Y1J+cqkfGVSvjIpX5mUr0zKVyblK5PylXlfvjLvy1fmffnGvC/fmPflG/O+fGM+fW3bKd+PxXz62phPXxuT8o1J+YakvAYk5TUgKa8BSXkNSMprQFJeA5LyGpCU14CkvAYk5TUwKR+ZlI9Mykcm5SOT8pFJ+cikfGRSPjIpH5mUj0zKJyblE5PyiUn5xKR8YlI+MSmfmJRPTMonJuXv2giY7RVLJy+Pcv3wxz9bN1ZhxqobYml9bo6PFvqxGjLWXVvb7o4VmbESM9aW38T63DYZS6jdWMqMZcxYlRmrIWOVwIwVmbESM1ZmxhJmLCblC5PyhUn5spvyMXZj7aZ8P5bupvwg1m7KD2Ltpvwg1m7KD2Ltpvwg1m7Kd79SQXU35QexdlN+EGs35QexdlC+JLtiSffPVwvMWJEZKzFjZWYsYcYqzFjKjGXMWJUZi0n5yqR8ZVK+7qZ8Sd1Yuyk/iLWb8oNYuyk/iLWb8oNYuyk/iLXnWr7OYu25Y/M6W9r7kgBtgRlrC+Vff5Bp6P6x3xIz1g7Ka7gec2qybixhxtpC+RcgNPff8sqMZcxYlRlry6dGcr5ideVjITBjxc3/EUvpxkrMWJkZS5ixdlN+EGs35dW6sXZTfhBrN+UHsRoyVgzMWLspP4i1m/KDWLspP4i1m/KDWDsoP/2Ap0VlxjJmLOQnwC0iPwFuCfkJcEvIT4BbQn4C3FJmxhJmLCblE5PyiUn5tJvysXsPIu2mfD9W3k35QazdlB/E2k35QazdlB/E2k35QazdlB/E2k35QazdlB/EYlJ++27OfqztuzkHsZiU376bcxCLSXlhUl6YlBcm5YVJeWFSXpiUL0zKFyblC5PyhUn5wqR8YVK+MClfmJQvTMoXJuWVSXllUl6Z9+WVeV9ed1N+EIt5X16Z9+WVeV9emU9flfn01ZhPX4359NWYlDcm5Y1JeWNS3piUNybljUl5Y1K+MilfmZSvTMpXJuUrk/KVSfnKpHxlUr4yKV+ZlG9Myjcm5RuT8o1J+cakfGNSvjEp35iUb0zKNyTla0BSvgYk5WtAUr4GJOVrQFK+3rQRMGa9Yj1WncSaftNDvWkj4O2xZEOsN/4jFmYsZcYyZqyKjJW2/CbOhm3XmzZr3R4rM2MJM1ZhxlJmLGPGqsxYDRkrB2YsJuUzk/KZSfm8m/Ldsfc176b8INZuyg9i7ab8INZuyg9i7aZ8P5bspvwg1m7Kd7+7oMpuyg9i7ab8INZuyg9i7aD8dNh2FWXGMmasyozVkLFKYMaKzFiJGSszYwkzFpPyhUn5wqR82U357ojfWnZTvh9Ld1N+EGs35QexdlN+EGs35Qex9lzL11msPXdsXmdLQzeWMmNtofzsmx6qVmasHZSfftNDtcCMtYXys+8uqJaYsTIzljBjbfnUyOybHqopM5Zt/o/Y/ZKAapUZqyFj1cCMtZvyg1i7Kd8d5F7rbsoPYu2m/CBWYcZSZqzdlB/E2k35QazdlO/HarspP4i1g/LzD3i2xIyVmbGEGYv5CfDG/AR4Y34CvDE/Ad4aMVYLgRkLSfkWkJRvAUn5FnZTvjsJr4XdlB/E2k35QazdlB/E2k35QazdlO/HirspP4i1m/KDWLspP4i1m/KDWEzKb9/NOYjFpPz23ZyDWEzKRyblE5PyiUn5xKR8YlI+MSmfmJRPTMonJuUTk/KJSfnMpHxmUj4zKZ+ZlM9Mymcm5TOT8plJ+Yy8L98y8768MO/LC/O+vDDvywvzvrzspvwgFvLpaxPk09cmyKevTZiUFyblC5PyhUn5wqR8YVK+MClfmJQvTMoXJuULk/KFSXllUl6ZlFcm5ZVJeWVSXpmUVybllUl5ZVJemZQ3JuWNSXljUt6YlDcm5Y1JeWNS3piUNybljUn5yqT8Tbs5Q4uvWEH//PIcr6EeOba/7H399xenLM8kKZfX7MNSXx3EQYeC72Dl6lBDt4M66GAOOlR8hxaeHeTLQ9+vHdr5HW7aCLu3Q3TQITnowPf0vAPf0/MOfE/PO/A9Pe/A9/S8gwNPt+M9bSEc7+lHh7M83bodzvJ0v8NZnu53OMvT/Q5nebrf4SxP9zts8bTGVwf9c4f4KPG8R5bKlxenzourpX+9toVX5v/8Ro5//7mx6vVzv3xnx+Of17mpv+dmeG7a77kZnZsYfs/N8NzE33MzPDfp99wMz03+PTfDcyO/52Z4bsrvuRmeG/09N8Nz83tdPD43v9fF43Pze108PDfp97p4fG5+r4vH5+b3unh8bn6vi8fnRn7PzfDc/F4Xj8/NwdfFV4eDr1+vDvzrzJquDjV3O/CvB6cdMv+6bd6Bf30178C/Dpp3wF+v5HBxKcfQ7SAOOuD9/0YHvKfnHQTPVinXd79JkW4HPFvf6ID/nS5Rnh1Kqd0O+N/pYtfvQ6n9Dvjf6Tc64K+9v36zau56WvDX3iqvDl+/oO9LB/y197xDwfvhjQ54P7zRAX/trfr6bmnrcqngr73f6ID3tGq9OtTutUbBe/qNDjs8ndL12ceUO7NIH7GMGasyYzVkLA3MWJEZKzFjZWYsYcbaoYQUwyuW/VkJOZXLH4+7fN0O6qCDOehQHXRo53ew4KBDdNAhwTuk14sf/3z9+fllm45lBx0E3yHb1UG62ziN7ul3OtA9/U4HuqdTKunqYNLtQPf0Ox3onn6jQ6V7+p0OdE+/04Hv6XkHvqfnHfiennfge3rege/peQcHnq4OPF0deLod5ekaux2O8vSgw1GeHnQ4ytODDkd5etDhKE8POhzl6UGHozw96HCUpwcdjvJ0t0MM53s6hvM9HcP5no7hfE/HcL6nYzjf0zGc7+kYzvd0DOd7OgYHno4OPB0deDo68HR04OktY7Tu7uDA09GBp6MDT0cHno7n3/eO6fzn0zGd/3w6pvOfT8d0/vPpuGWsz90dzn8+HdP5z6djOv/5dEznP5+OyYGnswNPZweezg48nR14esuYnLs7OPB0duDp7MDT2YGnswNPiwNPiwNPiwNPiwNPbxl9dXcHB54WB54WB54WB54WB54uDjxdHHi6OPB0ceDpLaOv7u7gwNPFgaeLA0/vGap1TUbLyf7S4YrVkLH2DNWax4rMWIkZa4vGhhNW/taLrw7ioEOBd5iPY4l7xnX9rQ6zMSBxz7iumztUBx0avsP0cmLPuK6bO0QHHZKDDnRPv9OB7ul3OvA9Pe/A9/S8A9/T8w58T887OPB0deDp6sDT9ShP97cH1KM8PehwlKcHHY7y9KDDUZ4edDjK04MOR3l60OEoT/c7tKM8PehwlKcHHRx4ujnw9J5xXTd3cODp5sDTzYGnmwNPt/M9ncL5nk7hfE+ncL6nUzjf0ymc7+kUzvd0Cud7OoXzPZ3C+Z5OwYGnowNPx/Pve6d4/vPpFM9/Pp32jOu6ucP5z6dTPP/5dIrnP59O8fzn0yme/3w6pfOfT6fkwNPJgaeTA0/vGdd1cwcHnk4OPJ0ceDo58HRy4OnswNPZgaezA09nB57eM67r5g4OPJ0deDo78HR24OnswNPiwNPiwNPiwNPiwNN7xnXd3MGBp8WBp8WBp8WBp8WBp4sDTxcHni4OPF0ceHrPuK6bO7A8fcViqfeKxbLpFYslyGesLZOfol6xYtM//35EKflfL37880uQ9OqQ8B3s1aHmbofsoIM46FAcdFAHHcxBh+qgQzu/w5aZUnd34Ht63uEoT7fQ7cD3dJNnhxK610tbZkrd3YHv6XkHvqfnHfiennfge3rege/paYfK9/S8A9/T8w58T887OPD0lplSd3dw4OnqwNPVgaerA09XB55uDjzdHHi6OfB0c+DpLTOl7u7gwNPNgaebA083B55u53s6h/M9ncP5ns7hfE/ncL6nczjf0zmc7+kczvd0Dud7OofzPZ2DA09HB56ODjwdHXg6OvD0lplSd3dw4OnowNPRgaejA09HB55ODjydHHg6OfB0cuDpLTOl/ubn+dKswwGf9552OODz3tMOB3zee9rhgM97Tzsc8HnvWYd8wOe9px0O+Lz3tAPf01pmHfiennfge3rege/peQe+p+cd+J6ed8B7uuR4dcja7YD39LyD4D39Rge8p9/ogPf0Gx3wni4pvzpYtwPe0290wHv6jQ54T7/RAe/pNzrwPT3vwPf0tEPhe3rege/peQe+p790kO61dznA06/7GqV2Oxzg6WmHAzw97XCAp6cdDvD0tMMBnp52OMDTsw56gKenHfiejjLrwPf0vAPf0/MOfE/PO/A9Pe/A9/S8A9/T8w58T8878D097cCfR/ZGh5v8EF8dQpl2qPbqUP7cIT1uH/3rxenxV+f14tdc3XzXHKytHQq+g5WrQw3dDuqggznoUPEdWnh2kJi6Hdr5He6ag7W1Q3TQITnowPf0vAPf0/MOfE/PO/A9Pe/A9/S8gwNPVweebg483c7ydOt2OMvT/Q5nebrf4SxP9zuc5el+h7M83e+wxdN/5x7Zo8TzHlkqf/lM4r+/uF57JdqXjySn3Pu5ser1c1P++uLr3NTfczM8N+333AzOjYTwe26G5yb+npvhuUm/52Z4bvLvuRmeG/k9N8NzU37PzfDc6O+5GZ6b3+vi8bn5vS4en5vf6+LhuYm/18Xjc/N7XTw+N7/XxeNz83tdPD438ntuhufm97p4fG4Ovi6+Ohx8/Xp14F9n1mufRep+F6tE/vXgtEPiX7fNO/Cvr+Yd+NdB8w7465UcLi7lGLodxEEHvP/f6ID39LxDxrNVyuu7uot0O+DZ+kYH/O/0dK+IZPzvdLHr96HUfgf87/QbHfDX3hqu2W2au57O+GtvlVeHUrod8Nfe8w6C98MbHfB+eKMD/tpb9eKSWpdLgr/2fqMD3tOq9epQu9cagvf0Gx12eDql67OPKaevHa5YxoxVmbEaMlYJzFiRGSsxY2VmLGHG2qGEFMMrlv1ZCTmVyx+Pu3zdDuqggznoUB10aOd30OCgQ3TQIcE7pNeLH/98/fn52qYjmh10EHyHbFcHSd0OdE+/04Hu6Xc60D2dUklXB5NuB7qn3+lA9/QbHYzu6Xc60D39Tge+p+cd+J6ed+B7et6B7+l5B76n5x0ceNoceNoceLoe5ekaux2O8vSgw1GeHnQ4ytODDkd5etDhKE8POhzl6UGHozw96HCUpwcdjvJ0v0Nz4OnmwNPNgaebA09vGdd2dwcHnm4OPN0ceLo58HQ739MlnO/pEs73dAnne7qE8z1dwvmeLuF8T5dwvqdLON/TJZzv6RLOv+9d4vnPp0s8//l0iec/ny7x/OfTZctYn7s7nP98usTzn0+XeP7z6RLPfz5dogNPJweeTg48nRx4Ojnw9JYxOXd3cODp5MDTyYGnkwNPJweezg48nR14OjvwdHbg6S2jr+7u4MDT2YGnswNPZweezg48LQ48LQ48LQ48LQ48vWX01d0dHHhaHHhaHHh6z1CtazJaTvaXDleshoy1Z6jWPFZkxkrMWFs0Npyw8rdefHUQBx0KvMN8HEvZM67rb3WYjQEpe8Z13dyhOujQ8B2mlxN7xnXd3CE66JAcdKB7+p0OdE+/04Hv6XkHvqfnHfiennfge3rewYGnzYGnzYGn7ShP97cH2FGeHnQ4ytODDkd5etDhKE8POhzl6UGHozw96HCUp/sd6lGeHnQ4ytODDg48XR14es+4rps7OPB0deDp6sDT1YGnqwNPNweebg483Rx4ujnw9J5xXTd3cODp5sDTzYGnmwNPt/M9reF8T2s4/763hvOfT2s4//m0hqM8Pehw/vNpDec/n9Zw/vNpDec/n9Zw/vNpjec/n9bowNPRgaejA0/vGdd1cwcHno4OPB0deDo68HR04OnkwNPJgaeTA08nB57eM67r5g4OPJ0ceDo58HRy4OnkwNPZgaezA09nB57ODjy9Z1zXzR0ceDo78HR24OnswNPZgafFgafFgafFgafFgaf3jOu6uQPL01cslnqvWCybXrFYgnzG2jL5KeoVKzb98+9HlJL/9eLHP78ESa8OCd/BXh1q7nbIDjqIgw7FQQd10MEcdKgOOrTzO2yZKXV3B76n5x2O8nQL3Q58Tzd5diihe720ZabU3R34np534Ht63oHv6XkHvqfnHfiennYwvqfnHfiennfge3rewYGnt8yUuruDA0+bA0+bA0+bA0+bA09XB56uDjxdHXi6OvD0lplSd3dw4OnqwNPVgaerA09XB55uDjzdHHi6OfB0c+DpLTOl7u7gwNPNgaebA083B55u53vawvmetnC+py2c72kL53vawvmetnC+py2c72kL53vawvmetuDA09GBp6MDT0cHno4OPL1lptTf/DxfmnU44PPe0w4HfN572uGAz3tPOxzwee9phwM+7z3rkA74vPe0wwGf95524Htay6wD39PzDnxPzzvwPT3vwPf0vAPf0/MOeE+XHK8OWbsd8J6ed8h4T7/RAe/pNzrgPf1GB7ynS8qvDtbtgPf0Gx3wnn6jA97Tb3TAe/qNDnxPzzvwPT3tIHxPzzvwPT3vwPf0lw7SvfaWAzz9uq9RarfDAZ6edjjA09MOB3h62uEAT087HODpaYcDPD3rUA7w9LQD39NRZh34np534Ht63oHv6XkHvqfnHfiennfge3rege/peQe+p6cd+PPI3uhwix+0XA9rHv+28PXl10qybKWybCVdtpItW+kWuqgmuVbSEv/88pTl+cNTLq+hc6/hyXbPYKTbY90z6+jvxrJyxaqhGysyYyVmrLwjVgvPWBJTN5YwYxVmLGXGMmasyozVkLFqYMaKzFiJGYtJ+cqkfGVSvm6nfOvG2k75fqztlO/H2k75bqy2nfL9WNsp3491D+VLsy+x0p9fHos+72fYX0aT//tL6/Wx9vbl06Mp935qrNePTSl/ffFVNv+ksvKTypafVFZ/Uln7SWXrTyrbfk7Zes9UmVPKxp9U9gddQdXwg66gapCfVPYHXUHV8IOuoGr4QVdQNfygK6gaftIVVPxJV1CRdAV1hSJd6VyhNlyRpPD89E4KqRtKiKEKMZQSQxkx1AazpXzdP86xG6oBQ6VADBWJoTYgQa9vENdSuqGUGGrDG93i88Wm0guVN7zRH4+Un6GadkNFYqhEDJWJoYQYqhBDKTGUEUNVYqgGDCVEostWoj/uTHZDbSH688MXj2vMbqhMDLWD6KaTUBuI/tDIM5T03+hKDGXEUJUYqgFDlUAMFYmhEjFUJoYSYqi9RO//2V62EP0SsnXdV4wYqhJDNWAoDcRQkRgqEUNlYqgdRE86CVWIoZQY6qaNI5quUBYmL4/tShWbvMYCvD7cX+/aBH53rIaMddcm8LtjRWasxIyVmbFkfayU4vX4L8XSjVWYsXRHrGxXLEndWMaMVZmx2o5YJV2xTHqxamDGisxYiRkrM2MJM1ZhxlJmLGPGqsxYTMo3JuUbk/JtN+Vr7MbaTflBrN2UH8TaTflBrN2UH8TaTflBrN2UH8TaTflurBZ2U34QazflB7GQlG8BSfkWkJRvAUn5FpCUbwFJ+RaQlG+BSfnIpHxkUj4yKR+ZlI9Mykcm5SOT8pFJ+cikfGRSPjEpn5B3bFpC3pdvCXlfvqXdlB/EQt6Xbwl5X74l5H35lpD35VtC3pdvGXlfvmUm5TOT8plJ+cykfGZSPjMpn5mUz0zKZyblhUl5YVJemJQXJuWFSXlhUl6YlBcm5YVJeWFSvjApX5iUL0zKFyblC5PyhUn5wqR8YVK+MClfmJRXJuWVSXllUl6ZlFcm5W/a9/qaCPyf/7avL79W0mUr2bKV6rKV2qqVbtoa+peVaumuFJetdM8v3+Nu8LXS4zZZd6WybCVdtpItW6kuW+me36d2TTJ+/Fvyn18+21rfbtqvd3OoSAyViKEyMZQQQxViKF0fKtZrouHjn71vrWw37dG7PVbdEKvF56sf/9RurIaM1QIzVtwRazZBorXEjJWZsYQZqzBjKTOWMWNVZqwGjFVDCMxYRMo/YhEp/4hFpPwjFpHyj1hEyj9i7aZ8Kd1Yuyk/iLWb8oNYuynfjxV3U34QazflB7F2U17/MrGr8+LSnq+117aY/KXBbiEMTuxuIQxi7RbCIBZTCJEphMgUQmQKITGFkJhCSLuFMIjFpHxiUj4xKZ+YlE9Myicm5ROT8plJ+cykfGZSPjMpn5mUz0zKZyblM5PymUn5zKS8MCkvTMoL8xa+MG/hy27KD2Ixb+EL8UHtIxbxQe0jFvFB7SMW80FtYT6oLcwHtYVJ+cKkfGFSvjApX5iUL0zKFyblC5PyyqS8MimvTMork/LKpLwyKa9MyiuT8sqkvDIpb0zKG5PyxqS8MSlvTMobk/LGpLwxKW9MyhuT8pVJ+cqkfGVSvjIpX5mUr0zK//P7Ua+V6rKV2qqV/vmNoNdKcdlK9/z+lGbXSlrS5OXlGvHw5dHktZv7EapsCGXPXdNapRtKiaGMGKoSQzVeqHjTpsObQ0ViqEQMlYmhhBhqL9Fb7obaQfTrxRasG8qIoSoxVAOGioEYKhJDJWKoTAwlxFCFGIpI9EgkeiQSPRKJnohET0SiJyLRE5HoiUj0RCR6IhI9EYmeiERPRKJnItEzkeiZSPRMJHomEj0TiZ6JRM9Eomci0TOR6EIkuhCJLkSiC5HoQiS6EIkuRKILkehCJLoQiV6IRC9Eohci0QuR6IVI9EIkeiESvRCJXohEL0SiK5HoSiS6EomuRKIrkehKJLoSia5EoiuR6EokuhGJbkSiG5HoRiS6EYluRKIbkehGJLoRiW5Eolci0SuR6JVI9EokeiUSvRKJXolEr0SiVyLRK5HojUj0RiR6IxK9EYneiERvRKI3ItEbkeiNSPQGJHoKQKKnACR6CkCipwAkegpAoqcAJHoi7hlNxD2jacueUcuTUDuIrvrnUFv2jE5DRWKoDUS3/NxGbhK6oTIxlBBDFWIoJYbaQHS7xkeZxG6oSgzVgKF27Bmdh4rEUIkYKhNDCTFUIYbSraFKl+hpC9HLM5RKN9QOokebhGrAUDv2jM5DRWKoRAyViaGEGOoeTkmqVyjJ9vXl10p12Upt1Uo3bUR8Z6W4bKWybKWb3hGv+aKP34fWXamtWummjUzvrBSXrZSWrXTTe6+W13uvhe5KumwlW7ZSXbbSTb9PLb3eEbH8+eUPfz5/eMrlNeHxNe863bTn5PZYcUcsK1esGrqxEjNWZsaSHbFaeMaSmLqxCjOWMmMZM1ZlxmrIWBaYsSIzVmLGysxYTMobk/LGpLxtp3zrxtpO+X6s7ZTvxqrbKd+PtZ3y/VjbKd+PddN92Fi/3Dmo/7XzF+ld207eWKksW0mXrWTLVqrLVvoHuNZfqf3j9/z+/eX1egBZrfsAskViqEQMlYmhhBiqEEMpMZStDxVrfX7M7PHPro9b3RCrxefX0j3+qd1YjRgrh8CMFXfEmn3ZZA6JGSszYwkzVmHGUmYsY8aqzFgNGSsGZiwm5SOT8pFJ+cikfGRSPu6m/JevJ/4aazflB7F2U34Qazfl+7HSbsoPYu2m/CDWbsrrXx7sdF5c2vO19toUkL802C2EwYndLYRBrN1CGMRiCiExhZCYQkhMIWSmEDJTCHm3EAaxmJTPTMpnJuUzk/KZSfnMpHxmUl6YlBcm5YVJeWFSXpiUFyblhUl5YVJemJQXJuULk/KFSfnCvIVfmLfwy27KD2Ixb+EX5oPawnxQW5gPagvzQa0yH9Qq80GtMimvTMork/LKpLwyKa9MyiuT8sqkvDEpb0zKG5PyxqS8MSlvTMobk/LGpLwxKW9Mylcm5SuT8pVJ+cqkfGVSvjIpX5mUr0zKVyblK5PyjUn5xqR8Y1K+MSnfmJRvTMr/85tkr5Vs2Up12UqrxodKCMtWuufXOthrWGQM8c8vfwjhOY74AeEvo4vDK5YwYxVmLGXGMmasyozVkLFu2hd5e6zIjJU2xKqtvGLlr7H+/cXzObUSs4MOgu8wGzUrsTjooA46GL7DbBaixOqgQzu/QwoOOkQHHfiennfge3rege/peQe+p+cd+J6ed3Dg6eTA08mBp/NZnm7dDmd5ut/hLE/3O5zl6X6Hszzd73CWp/sddns6dW975S13evP1w5tYN1ZlxmrIWBKYsSIz1g4zvZ7w5q9PeD+9SyoZ32F6d+6m7dd7OxQHHRTfYXrVL+agQ3XQoZ3foQQHHaKDDnxPzzvwPT3vwPf0vAPf0/MODjxdHHi6OPB0OcvT3Tsqepan+x3O8nS/w1me7nc4y9P9Dmd5ut9ht6dL95aR7lbv1y+p+hJrt00HsXY/Cv0yUfxrrC1PN+V1O7KWP/9+zLeBiAUHHaKDDslBh+yggzjoUBx0UHiHlOJ17ZFi6XYwfIdsVwfp/l1n1UEHuqff6FDpnk6ppKuDSbcD3dPvdKB7+p0OdE+/04Hu6Xc60D39Tge+p+cd+J6ed+B7et6B7+lph+bA082Bp5sDT7ejPF1jt8NRnh50OMrTgw5HeXrQ4ShPDzoc5elBh6M83e1QwlGeHnQ4ytODDkd5etDhfE+XcL6nSzjf0yWc7+kSzvd0Ced7ugQHno4OPB0deDo68HR04Ok906xu7uDA09GBp6MDT0cHno4OPJ0ceDo58HQ6/753Sec/ny57plnd3OH859Mlnf98uqTzn0+XdP7z6ZLOfz5d8vnPp0s+//l0yQ48nR14es80q5s7OPB0duDp7MDT2YGnswNPiwNPiwNPiwNPiwNPb5ntdXcHB54WB54WB54WB54WB54uDjxdHHi6OPB0ceDpLbO97u7gwNPFgaeLA08XB54uDjytDjytDjytDjytDjy9ZbbX3R0ceFpZnr5isdR7xWLZ9IrFEuQz1j0zpYrV55tYSw3lzy9/vHOeP/xxWlo3VmbGEmaswoylzFi2I5bmZywLYaKE6VdxlHtGLm3u0PAdZl9jUe4ZubS5Q3TQIeE7zMZjl5oddBAHHYqDDuqgA9/T8w58T8878D097dD4np534Ht63sGBp5sDT98zcmlzh7M83bodzvJ0v8NZnu53OMvT/Q5nebrXQcNZnu532OFpy+XqoH/pcMVKzFg7bGpRXrHSn/+LP/4efP4Xf1yC9TuIgw7FQQd10MEcdKgOOrTzO8QA7zD/ggyNEd9h9sUMGpODDnRPv9OB7un5h0E00j39Tge6p9/pQPf0Ox3onn6nA93Tb3RIfE/PO/A9Pe/A9/S8A9/T8w4OPJ0ceDo58HQ6ytPdgW2ajvL0oMNRnu53yEd5etDhKE8POhzl6UGHozw96HCUpwcdjvL0oMNRnh50cODp7MDT2YGnxYGnxYGnxYGnxYGn7xmMtLmDA0+LA0+LA0+LA0+LA08XB54uDjxdHHi6OPD0PYORNndw4Oni4L53cfB8ujh4Pl0cPJ9WB8+n1cHzaXXwfFodPJ++ZzDS5g4Onk+rA0+rA0+rA0+rA0+bA0+bA0+bA0+bA09vGdd1dwcHnjYHnjYHnjYHnjYHnq4OPF0deLo68HR14OktU8Pu7uDA09WBp6sDT1cHnq4OPN0ceLo58HRz4OnmwNNbpobd3WGLp9s1lLqm+rXDFUuZsbbYtNkVK2s3VmXG2uG8x5/EVyxLnVi2ZajWG7EiM1ZixsrMWDuUUO1SQm02UcJ0EL1tGX319zrMBqDbltFXd3cwBx0qvsNssKptGX11c4cto6/u7hAddEgOOmQHHfiennfge3rege/peQe+p+cdHHg6OvB0cuDpdJanW7fDWZ7udzjL0/0OZ3m63+EsT/c7nOXpfofNnm6h9/2LliozVkPGyoEZa4vzhhOv/9aLrw7JQYcM7zB/JGdbxkjd3aGc1KG77dW2jJG6u4M56FAddGjnd9gyRuruDnRPv9OB7ul3Ohzl6UGHozw96ODA0+LA0+LA0+LA0+LA08WBp4sDTxcHni4OPL1ljNTdHRx4ujjwdHHg6eLA08WBp9WBp9WBp9WBp9WBp7eMkbr5vrce5elBh6M8PehwlKcHHY7y9KDDUZ7ud7CjPD3ocJSnBx2O8vSgg4Pn01vGSN3dwYGnzYGnzYGnzYGnzYGnqwNPVweerg48XR14essYqbs7OPB0deDp6sDT1YGnqwNPNweebg483Rx4ujnw9JYxUnd3cODp5sDTzYGnmwNPt/M9XcP5nq7hfE/XcL6nazjf0zWc7+kazvd0Ded7uobzPV0Dy9NXLJZ6n7Eiy6ZXLJYgr1g3sTbnK5Z9mXbYfXmO9TneMcdWJr8f0zmK9a75TFs7KL7DbAZhvWs+09YO1UGHhu8wm21U75rPtLVDdNAhOeiQHXTge3rege/peQe+p+cd+J6ed+B7et7BgaezA09nB57OZ3m6dTuc5el+h7M83e9wlqf7Hc7ydL/DWZ7ud9jiaY2vDvrnDvFR4l8vjql8eXHqvLja8+5bC6/MKfd+bqx6/dyUv774Ojft99yMzo2E33MzPDfx99wMz036PTfDc5N/z83w3MjvuRmem/J7bobnRn/PzfDc2O+5GZ6b3+vi8bn5vS4enpvye108Pje/18Xjc/N7XTw+N7/XxeNzI7/nZnhufq+Lx+fm97p4fG4Ovi6+Ohx8/Xp14F9nXp/2fPwz9zoo/3pw3oF/3TbvwL++mnfgXwfNOwi9Qw4Xl/LXz2R/6YC/rnijA97/b3TAe3rewfBslfL80Y9/SrcDnq1vdMD/Tpf4/O69WB4P8Hsd8L/Txa7fh1L7HfC/0290wF97a3juUYiau542/LW3yqtDKb0OFX/t/UYHvB/e6ID3wxsd8NfeqheX1LpcumsO2tYOeE+r1qtD7V5rVLyn3+iww9MpXZ99TDl97XDFqsxYDRmrBWasyIyVmLEyM5YwYxVmrB1KSDG8YtmflfDGqIJmDjpUBx3a8R1aCA46RAcdkoMOGd4hvV78+Ofrz8/XNp3HU20HHQq+Q7arg6RuB7qn3+lA9/Q7Heieno8Na4Hu6Tc6RLqn3+lA9/Q7HeiefqcD39PzDnxPzzvwPT3vwPf0vAPf0/MODjwdHXg6OfB0OsrT3a/2bekoTw86HOXpQYejPD3ocJSnBx2O8vSgw1GeHnQ4ytODDkd5ut8hH+XpQQcHns4OPJ0deHrLuLa7OzjwdHbg6ezA09mBp7MDT4sDT4sDT4sDT4sDT28Zz3V3BweeFgeeFgeeFgeeFgeeLg7uexcHz6eLg+fTxcHz6S3jgu7u4OD5dHHwfLo4eD5dHDyfLg6eT6sDT6sDT6sDT6sDT28Zk3N3BweeVgeeVgeeVgeeVgeeNgeeNgeeNgeeNgeeNgeeNgeeNgeeNgeeNgeeNgeerg48XR14ujrwdHXg6S2jr+7u4MDT1YGnqwNPVwee3jNU65qMlpP9pcMz1p6hWvNYkRkrMWNlZqwtGivX5MBU059/bd8Yx7JnAtfNHRTe4Y1xLHvGdf2tDtMxIHvGdd3coZ3eoYU947r+VofJ5cSjQ3TQITnokB10oHv6nQ50T7/Tge/peQe+p+cd+J6ed+B7etohOvB0dODp6MDT8ShP97YHPDoc5elBh6M8PehwlKcHHY7y9KDDUZ4edDjK0/0O6ShPDzoc5elBh6M8PejgwNN7xnXd3MGBp5MDTycHnk4OPJ0ceDo78HR24OnswNPZgaf3jOu6uYMDT2cHns4OPJ0deDo78LQ48LQ48LQ4uO8tDp5P7xnXdXMHB8+nxcHzaXHwfFocPJ8WB8+ni4Pn08XB8+niwNPFgaf3jOu6uYMDTxcHni4OPF0ceLo48LQ68LQ68LQ68LQ68PSecV03d3DgaXXgaXXgaXXgaXXgaXPgaXPgaXPgaXPg6T3jum7u4MDT5sDT5sDT5sDT5sDT1YGnqwNPVweerg48vWdc180dHHi6sjx9xWKp94rFsukViyXIZ6wtk5+iXrFi0z//fkQpzx/9+OeXIOnVIeM72KtDzd0O4qBDcdBBHXQwBx2qgw7t+A5xy0ypuztEBx34np53OMrTLXQ78D3d5NmhBOl24Ht63oHv6XkHvqfnHfiennfge3raIfI9Pe/A9/S8A9/T8w58T887OPB0dODp6MDT0YGnowNPRweeTg48nRx4OjnwdHLg6S0zpe7u4MDTyYGnkwNPJweeTg48nR14OjvwdHbg6ezA01tmSt3dwYGnswNPZweezg48nR14Whx4Whx4Whx4Whx4estMqbs7OPC0OPC0OPC0OPC0OPB0ceDp4sDTxYGniwNPb5kpdXeHAz7vnWYdDvi897TDAZ/3nnY44PPe0w4HfN571kEP+Lz3tMMBn/eedjjg897TDnxPa5l14Ht63oHv6XkHvqfnHfiennfge3reAe/pkuPVIWuvg+E9/UYHvKff6ID39Bsd8J5+owPe0yXlVwfrdsB7+o0OeE+/0QHv6Tc64D39Rge+p6cdKt/T8w58T8878D0978D39JcO0r323jJT6m92eN3XKLXb4QBPTzsc4OlphwM8Pe1wgKenHQ7w9KxDO8DT0w4HeHrage/pKLMOfE/PO/A9Pe/A9/S8A9/T8w58T8878D0978D39KxD4s8je6MD39PzDvf4QTVcHbSVSYeU7PnDk70K/2fCzs9+nZ3SbVDoDez5H0GrdBvo8Q3s+Ab1+Abt9AY3zb7a2SAe3yAd3yAf3wDv5GmDg5zccrcB3snt+VoL1m2Ad/K0Ad7J0wZ4J88aJLyTpw3wTp42wDt52gDv5GkDvJOnDfBOnjY43snpeCen452cjndyPt7J+Xgn5+OdnI938k2zrHY2ON7J+Xgn5+OdnI93cj7eyXK8k+V4J8vxTpbjnXzT3KqdDY53shzvZDneyXK8k+V4J5fjnVyOd3I53snleCffNKNqZ4PjnVyOd3I53snleCeX452sxztZj3eyHu9kPd7JN82j2tngeCfr8U7W452sxztZj3eyHe9kO97JdryT7Xgn3zR7ameD451sxzvZjneyHe9kO97J9Xgn1+OdXI93cj3eyTfNmdrZ4Hgn1+OdXI93cj3eyfV4J7fjndyOd3I73snteCffNFNqZ4PjndyOd3I73snteCe3052cw+lOzuF0J+dwupNzON3JOZzu5Myf4zVtcLqTM3+O17TB6U7O/Dleswb8OV7TBsc7mT/Ha9rgeCfz53hNGxzv5OPneOXj53hl/hwvy5MGeCer/rkBf47XtAHeydMGdCdbfk5FNAndBnQnzxvQnTxvQHfyvAHdyfMGdCdbulgksduA7uR5A7qTpw3wc7zmDehOnjfAO3naAO/kaQO8k6cN8E6eNsA7+dWgdJ2Mn+Nl6fmF9qbSbYB3crRJA7yTZw3wc7zmDfBOnjbAO3naAO/kaQO8k6cNdvggxCfjc0jytcEVqzJjNWSsLSOc3ogVmbF2gDPUdMVq6c+/tOnx9v/Xi1MuudshO+gg+A5Wrg41dDsUBx3UQQfDd2jPH50kpm6H6qBDO7/DluFLd3eIDjrwPT3vwPf0vAPf0/MOfE/PO/A9Pe/gwNPqwNPqwNN2lqdbt8NZnu53OMvT/Q5nebrf4SxP9zuc5el+hy2eLq/bXm1yUziW50PC+OX+8eOm8L+/tNrz1LTwSpxy76fGev3YlPLXF19nxn7PzODM1N8zMzgz7ffM9M/MluFXZ5yZ+HtmBmcm/Z6ZwZnJv2dmcGbk98wMzkz5PTODM/N7DTw6M7/XwKMz83sNPDozv9fAgzPTfq+BR2fm9xp4dGZ+r4FHZ+b3Gnh0ZuT3zAzOzLHXwFeDY69Vrwb0a8oU4vOmeUjdBvRrv3kD+jXarIEE+rXUvAH9mmfegH5tkvL1+CvHbgP6NcS8Ad318wZ0J88b0GmqJV8/ufQaRDpN5w3ov8mzzU0S6b/JVq/Nrk27Dei/yfMG9KvreQP61fW8Af3qet6A7oNpg0T3wbwB/ep63oB+dT1vgHfytMHxTk7nOLmG7pVd4jv5OVqsptBtwHfyrAHeyaaTBnQn13z9Hkj3NznTnTxvQHfyvAHdyfMGdCfPG9CdPG9Ad/K8Ad3J8wZ0J88b0J08b3CQk/t3HYXv5OvKzrrXRcJ38qwB38mzBnwnzxrwnTxrwHfyrAHfybMGfCfPGuCdfI1cHTXAO3nWoOCdPG2ww8kxXD88pvbnBjnna6pjFvn64qtDctAhO+ggDjoUBx3UQQdz0KHCO6QUr48bpVi6Hdr5HbbMrft7Ha73UkqSuh3onn6nA93T73Sgezqlkq4O1uXSlrl1d3ege/qdDnRPv9OB7ul3OvA9Pe/A9/S0g/E9Pe/A9/S8A9/T8w4OPL1lbt3dHRx42o7ydI3dDkd5etDhKE8POhzl6X6HepSnBx2O8vSgw1GeHnQ4ytODDkd5etDhKE8POjjwdHXg6erA09WBp5sDTzcHnm4OPN0ceHrLrKK7OzjwdHPg6ebA082Bp9v5ni7hfE+XcL6nSzjf0yWc7+kSzvd0Ceff9y7h/OfTJZz/fLqE859Pl3D+8+kSz38+XeL5z6dLPP/5dInnP58uW6aI3d3BgaejA09HB56ODjwdHXg6OfB0cuDp5MDTyYGnt0wWu7uDA08nB55ODjydHHg6OfB0duDp7MDT2YGnswNPb5k2dncHB57ODjydHXg6O/B0duBpceBpceBpceBpceDpLRPI7u7gwNPiwNPiwNPiwNNbZpHFEq8ORXuxtgwYeyNWZMZKzFiZGUuYsQozljJjGTNWZcbaQ/mXqSxNTJXl+eKUS+512DPN6m91sHJ1qKHbITrokBx0yPgO7ZruJjF1O4iDDsVBB3XQwRx0qA468D097WB8T8878D0978D39LyDA0/vmWZ1cwcHnrazPN26Hc7ydL/DWZ7udzjL090O9SxP9zuc5el+h+2etm6sLeqV/IpV/3xq54Poy54BVTd3KA46qIMO5qBDddChnd9hz4Cqv9HhjQfHewZU3dwhOehA9/Q7HeiefqcD3dPvdKB7+p0OdE+/04Hu6Xc60D0976DhfE9rON/TGs73tIajPN0d7qThKE8POhzl6UGHozw96HCUpwcdjvL0oMNRnu53iEd5etDhKE8POhzl6UEHB57eM6Dq5g4OPB0deDo68HR04OnowNPJgaeTA08nB55ODjy9Z0DVzR0ceDo58HRy4OnkwNPJgaezA09nB57ODu575/OfT+ueAVU3dzj/+bTm859Paz7/+bTm859Pa3bwfFocPJ8WB8+nxYGnxYGn9wyourmDA0+LA0+LA0+LA0+LA08XB54uDjxdHHi6OPD0nglcN3dw4OniwNPFgaeLA08XB55WB55WB55WB55WB57eM2Ls5g4OPK0OPK0OPK0OPK0OPG0OPG0OPG0OPG0OPL1nxNjNHRx4estoq1Ce025zaPnPHR53j66f/OXnpleDRm9g8vzJVXoNtoy1urdBPL5BOr5BPr6BHN+gHN9Aj29gxzfAO3na4CAnf3nplwYN7+T2HNllwboN8E6eNsA7edoA7+RpA7yTpw3wTp42wDt52gDv5GkDvJOnDfBOnjSwcLqTLZzuZAunO9nC6U62cLqTLZzuZAunO9nC6U62cLqTLRzv5Hi8k+PxTo7HOzke7+Qt86vubXC8k+PxTo7HOzke7+R4vJPT8U5Oxzs5He/kdLyTt8yqurfB8U5Oxzs5He/kdLyT0/FOzsc7OR/v5Hy8k/PxTt4yl+reBsc7OR/v5Hy8k/PxTs7HO1mOd7Ic72Q53slyvJO3zKC6t8HxTpbjnSzHO1mOd7Ic7+RyvJPL8U4uxzu5HO/kLfOm7m1wvJPL8U4uxzu5HO/kcryT9Xgn6/FO1uOdrMc7ectsqXsbHO9kPd7JeryT9Xgn6/FOtuOdbMc72Y53sh3v5C1zpO5tcLyT7Xgn2/FO5s/xmjY43sn8OV7TBsc7mT/Ha9rgeCfz53hNGxzvZP4cr2mD453Mn+M1bXC8k4+f42XHz/Ey/hwvy5MGeCerThrgnTxtgHfytAHdyZafUxFNQrcB3cnzBnQnzxvQnTxrUPFzvOYN6E62dLFIYrcB3cnzBnQnzxvQnTxvQHfyvAHeydMGeCdPG+CdPG2Ad/KsAX6O15cGpetk/BwvS8/Xmkq3Ad7J0SYN8E6eNsA7edoA7+RpA7yTpw3wTp42wDt51uCm6T9Fv3z/lP7l5ddKZdlK9/xXKdZe/1VS667UVq1002SUd1aKy1ZKy1a66b133cN/rBRSdyVdtpItW6kuW+mmvxCCvFaK6c8vT1mePzzl8heePmPdNQLh7lhxRywrV6waurESM1ZmxpIdsdrzgiPJlxd/jVWYsZQZy5ixKjNWQ8YqgRkrMmMlZqzMjMWkfGFSvjApX7ZTvnVjbad8P9Z2yndj6XbK92Ntp3w/1nbK92PdRPlYvtw5qP+18xfpXbuZ31ipLFtJl61ky1aqy1b6B7jWX8n+8Xt+H/3yWWTGSsxYmRlLmLEKM5YyY9n6WLHWJ7ge/+zHqhtitRifsVrUbqyGjFUDM1bcEev6+EpsUruxEjNWZsYSZqzCjKXMWMaMVZmxGjJWC8xYTMo3JuUbk/KNSfnGpHzbTflSurF2U34QazflB7F2U74bq4XdlB/E2k35QazdlNe/PObpvLg8f3K0136A/KXBbiEMTuxuIQxi7RbCIBZSCC0ghdACUggtMIUQmUKITCHE3UIYxGJSPjIpH5mUj0zKRyblI5PykUn5xKR8YlI+MSmfmJRPTMonJuUTk/KJSfnEpHxiUj4zKZ+ZlM/IW/gtI2/ht7yb8oNYyFv4LSMf1LaMfFDbMvJBbcvIB7VNkA9qmyAf1DZhUl6YlBcm5YVJeWFSXpiUFyblhUn5wqR8YVK+MClfmJQvTMoXJuULk/KFSfnCpHxhUl6ZlFcm5ZVJeWVSXpmUVybllUl5ZVJemZRXJuWNSXljUt6YlDcm5Y1JeWNS/p/fJnutZMtWqstWWjVMtNWwbKXBr3XOr5Vyse6hg1+9bPY6tGr30PL5oYO3sMRwHSqxH9g+P7R+fmj7+NDRnrR3Do2fH5reODR1/+OM9l/JNUtjfKh8fmj5/FD9/FD7/ND6+aHtw0NjCIPtHKb16Y3Hv1vsH5u/cax849jyjWP1G8f2/+uapYuLZqX1j63fOLZ9fuzgs+zvHRu/cWz6xrH5G8fKN44dvK+s5dexTfrH6jeOtW8cW79xbPv82MGnZ61+Oc819c/z4COu7x2bvnFs/saxg/9G9TXX//Fv6x9bPz929EGxGK7/Ro9/1/6x6RvH5m8cK984tnzjWP3GsfaNY+s3jm2fHzv61Mtbxw7eV6G217Exf/Ovy/9cKK1aKK9aSFYtVFYtpKsWslUL1RsWSun66+bxz9JfqC1aaPThh7+5ULZrIUn9heKqhdKqhfItC5V0LWTSX0hWLVRWLaSrFrJVC9VVC7VFC2lYtVBctVBatdAqMugqMugqMujtZKixv5CtWqiuWqgtWsjCqoXiqoXSqoXyqoVk1UJl1UKryGCryGCryGCryFBXkaGuIkNdRYa6igx1FRnqKjLUVWSoq8hQV5GhriJDW0WGtooMbRUZ2ioytFVkaKv+mmir7jO0VfcZ2qr7DG3RfYYYwqqF4qqF0qqF8qqFZNVCZdVCumohW7VQXbXQKjLEVWSIq8gQV5EhriJDXEWGuIoMcRUZ4ioyxFVkiKvIkFaRIa0iQ1pFhrSKDGkVGdIqMqRVZEiryJBWkSGtIkNeRYa8igx5FRnyKjIMP8gn8bVQCV8Xeh1bvnGsfuNY+8ax9RvHts+PHX6QL9mXY8uf/4O+8bGoOPrU3/0LpRsWeuNjUXH0qb+/udD0Q0Rx9Km/+xcqqxbSWxaaY2T0qb/7F6qrFmqLFiph1UJx1UJp1UJ51UKyaqGyaqFVZCiryFBWkaHcTob+o5moYdVCcdVCadVCedVCsmqhsmohXbWQrVqorlpoFRlsFRlsFRlsFRlsFRlsFRlsFRlsFRlsFRlsFRlsFRnqKjLUVWSoq8hQV5GhriJDXUWGuooMdRUZ6qq/Juqq+wxt1X2Gtuo+Q1t1n6Gtus/QVt1naKvuM7RV9xnaqvsMbRUZ2iIypBBWLRRXLZRWLZRXLSSrFiqrFtJVC9mqheqqhVaRIa4iQ1xFhriKDHEVGeIqMsRVZIiryBBXkSGuIkNcRYa0igxpFRnSKjKkVWRIq8iQVpEhrSJDWkWGtIoMaRUZ8ioy5FVkyH+fDK9j8zeOlW8cW75xrH7j2NEvTk2vY2vuH1u/cWz7/NjhZ/PeOTZ+49jR+0q/fMizSv/Y/I1j5RvHlm8cq9841r5xbP3Gse2dY7sDRdPwk13vHBu/cWz6xrH5G8d+431VvvG+Kt94X5VvvK/KN95XpX1+rIZvHBu/cew3eKXf4JV+432l33hf6TfeV/qN95V+432l33hf2TfeV/aN95V9431l33hf2TfeV/aN95V9431l33hf2TfeV/aN91X9xvuqfuN9Vb/xvqrfeF/Vb7yv6jfeV/Ub76v6jfdV/cb7qn7jfdW+8b5q33hfDZ7SvjPsPQ0evFq115dT1Nr/22rwLPW9Y+0bx9ZvHDv4AoL2GmBuLabesXnwXPK9YwdfQNDy67/R151Nfzk2fePYwX/fVr9k7l8/59EXl7x1rH3j2PqNY9vnx46+uKTZ68saWgv9Y+M3jk3fODZ/41j5xrHlG8fqO8cO/huN3leW5sfWbxw72qT85R5UyF0+5+FEgneOjd84Nn3j2PyNY+Ubx5Y3jpXcP3a0Bz/F+bH2jWPb58cO96S/c2z8xrHpG8fmT45N8f+Stf/rG2O8vjfs8e9cu4fWzw9tHx/a/91979D4+aHp80Pz54fK54eWzw/Vzw/9/N2UPn83DX7dLb2+++7x79I7dPDb/tah8fND0+eH5s8Plc8PLZ8fqp8fap8fWj8/9PN3k3z+bpLP303y+btJPn83yefvJvn83SSfv5vk83eTfP5uks/fTeXzd1P5/N1UPn83lc/fTeXzd1P5/N1UPn83lc/fTeXzd1P5/N2kn7+b9PN3k37+btLP3036+btJP3836efvJv383aSfv5v083eTff5uss/fTfb5u8k+fzfZ5+8m+/zdZJ+/m+zzd5N9/m6yz99N9fN3U/383VQ/fzfVz99N9fN3U/383VQ/fzfVz99N9fN3U/383dQ+fze1z99N7fN3U/v83dQ+fze1z99N7fN30+gxUyqvxwGPZ8ndQ+vnh7ZPD7XRM6Z3Do2fHzp4Nz1uXV+H5lq6h+bPD5XPDy2fH6qfHzp4N0l6PUAQse6h9fND28eHjp5ovXNo/PzQwVui6OvQ0j/Do0dS7xxaPj9UPz/UPj509L3yD3tehz4U0T00f37oRx/K+D8Ptc8PrZ8f2j4+NIfPDx08W0lyPXOvybR7aPr80Pz5ofL5oeXzQ/XzQ+3zQ+vnhw7eTfma+/qf/+7+5ow+lv/OofHzQ9Pnh+bPDx28m3Kur0NLl/6jT+S/c6h+fqh9fmj9/ND28aGjD7a/c+jgNMnrerhK6r79Rx8vl/LlUM3dQ+vnh7aPDx19tlza6zSV2D1No4+Wv3No+vzQ/Pmh8vmhZXRo/nJo7R6qnx9qnx9aPz+0fXyohc8PHbybirzew6Wk7qGDd1Mp+jrU+qvmzw+Vzw8tb3QdHKqfH2qfH1o/P7R9fOjoc+TvHBo/PzR9fujo3SRf3v61y+HRZ8jfObR8fqh+fujg3aTxdaim7t2Q0efH/3Jo7vp19PFx/fJLp9b9i2P06fHHg9npofHzQwfvpsfN1OvQx9/HXw/9u1/P8H+ukxetI4vWKYvW0UXr2KJ16qJ12g3r/Hkz/n+uU0ezym5fJy5aJy1aJy9aRxatUxato4vWsUXr1EXrLOJBXMSDuIgH8XYe/NuA2/9znbxoHVm0Tlm0ji5axxatUxet09ask8KideKidRbxIC3iQVrEg7SIB2kRD9IiHqRFPEiLeJAX8SAv4kFexIO8iAd5EQ/yIh7kRTzIi3iQF/EgL+KBLOKBLOKBLLp/IIvuH8ii+wey6P6BLLp/IIvuH8ii+wey6P5BWXT/oCy6f1AW8aAs4kFZxIOyiAdlEQ/KIh6URTwoi3igi3igi3igi3igi3igi3igi3igi3igi3igi3igi3hgi3hgi3hgi3hgi3hgi3hgi3hgi3hgi3hgi3hgi3hQF/GgLuJBXcSDuogHdREP6iIejD6RZ+W1TvvrbLd/X0dLuT6q/p//7m2PqqMP8P0DK9VlK7VVK40+TfgPrBSXrZSWrZSXrSTLVirLVlrGiLaMEW0ZI9oqRrQQlq0Ul62Ulq2Ul60ky1Yqy1bSZSvZspXqspWWMSIuY0Rcxoi4jBFxGSPiMkbEZYyIyxgRlzEiLmNEXMaItIwRaRkj0jJGpGWMSMsYkZYxIi1jRFrGiLSMEWkZI/IyRuRljMjLGJGXMSIvY0Rexoi8jBF5GSPyMkbkZYyQZYyQZYyQZYyQZYyQZYyQZYyQZYyQZYyQZYyQZYwoyxhRljGiLGNEWcaIsowRZRkjyjJGlGWMKMsYUZYxQpcxQpcxQpcxQpcxQpcxQpcxQpcxQpcxQpcxQpcxwpYxwpYxwpYxwpYxwpYxwpYxwpYxwpYxwpYxwpYxoi5jRL3pXZ6/rJRbd6WybKWb3hHWrpX68/raXZ+qm69016fq3lgpLlspLVvpHmuohtdKrfz55emR5V+vTiqv8ayvj7S2mz6Cd3uswoylzFjGjFWZsRowloSbPpB4e6zIjJWYsYiUf8QiUv4Ri0j5Rywi5R+xiJR/xCJS/hGLSfnIpHxkUj4yKR+ZlI9Mykcm5SOT8pFJ+cikfGRSPjEpn5iUT0zKJyblE5PyiUn5xKR8YlI+MSmfmJTPTMpnJuUzk/KZSfnMpHxmUj4zKZ+ZlM9Mymcm5YVJeWFSXpiUFyblhUl5YVJemJQXJuWFSXlhUr4wKV+YlC9Myhcm5QuT8oVJ+cKkfGFSvjApX5iUVybllUl5ZVJemZRXJuWVSXllUl6ZlFcm5ZVJeWNS3piUNybljUl5Y1LemJQ3JuWNSXljUt6YlK9Mylcm5SuT8pVJ+cqkfGVSvjIpX5mUr0zKVyblG5PyjUn5xqQ8cu/rIxaT8si9r49YTMoj975K3LFtModYnj88JOnGSsxYG97yOUp+/vBotRtLmbGMGasyYzVkrB0bAXMqz8klOdlfuNWBXG7PH50kdiG3Y9fg7R2Sgw7ZQQdx0KE46KAOOpiDDtVBh3Z+h+TA08mBp5MDTycHnt6x/fQbHVq3w1me7nc4y9P9Dmd5ut/hLE/3O5zl6W6HfJan+x22eDrZq0P+c4dY9F+vjV9eqqnz0mrPb1Nv4ZU45d5PjfX6sSnlry++zkz6PTODM5N/z8zgzMjvmRmcmfJ7ZgZnRn/PzODM2O+ZGZyZ+ntmBmem/Z6Z/pmR8HtmBmfm9xp4dGZ+r4FHZ+b3Gnh0ZuT3zAzOzO818OjM/F4Dj87M7zXw6Mz8XgOPzszvNfDgzJRjr4GvBsdeq14N6NeUKcTnTfOQug3o137zBnJ8A/q11LwB/Zpn3oB+bZLy9fgrx24D+jXEvAHd9dMGSnfyvAGdplry9ZNLtwGdpvMG9N9ki8/Xmkq3Af032epzT4017TUw+m/yvAH96nregH51PW9Av7qeN6D7YN6A7oN5A/rV9bwB/ep63gDv5GmD451cz3FyDd0ru8p38vMTmTWFbgO+k2cN8E42nTSgO7nm6/dA+r/JdCfPG9CdPG9Ad/K8Ad3J8wZ0J08bNLqT5w3oTp43oDt53oDu5HmDg5zcv+vY+E6+ruyse13U+E6eNeA7edaA7+RZA76T/9wgBb6TZw34Tp414Dt51gDv5KSTBngnTxvgnTxtsMXJ9WqQo/65Qc759WKRry++OpiDDtVBh3Z+hz1z627uEB10SA46ZHiHlMrzE88PqfQ7iIMOxUEHuqff6UD39Dsd6J5+pwPd0290SHRPv9OB7ul3OtA9/U4HB57eM7fu5g4OPJ0ceDod5ekaux2O8vSgw1Ge7nfIR3l60OEoTw86HOXpQYejPD3ocJSnBx2O8vSgw1GeHnRw4OnswNPZgafFgafFgafFgafFgaf3TJa6uYMDT4sDT4sDT4sDT4sDTxcHni4OPF0ceLo48PSe6UI3d3Dg6eLA08XB8+ni4Pl0cfB8Wh08n1YHz6fVwfNpdfB8es/cqps7OHg+rQ6eT6sDT6sDT6sDT5sDT5sDT5sDT5sDT++ZJ3ZzBweeNgeeNgeeNgeeNgeerg48XR14ujrwdHXg6T0zxm7u4MDT1YGnqwNPVweerg483Rx4ujnwdHPg6ebA03vmjt3cwYGnmwNPNweebg483c73dA7nezpvmUI2HfuRt4wWeyNWZsYSZqx/3HnXSrpsJVu2Ul22Ulu10j8/GepaKS5b6R5UWX59Y5aVPPnlC/qcbPj455dY4RUrM2MJM1ZhxlJmLGPGqsxYDRnrpuk/t8eKzFhMyicm5ROT8olJ+cSkfGJSPjEpn5iUz0zKZyblM5PymUn5zKR8ZlI+MymfmZTPTMpnJuWFSXlhUl6YlBcm5YVJeWFSXpiUFyblhUl5YVK+MClfmJQvTMoXJuULk/KFSfnCpHxhUr4wKV+YlFcm5ZVJeWVSXpmUVybllUl5ZVJemZRXJuWVSXljUt6YlDcm5Y1JeWNS3piUNybljUl5Y1LemJSvTMpXJuUrk/KVSfnKpHxlUr4yKV+ZlK9Mylcm5RuT8o1J+cakfGNSvjEp35iUb0zKNyblG5PyDUl5CUjKS0BSXgKS8hKQlJeApLwEJOUlICkvAUl5CUjKS2BSPjIpH5mUZ+59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3ldh7n0V5t5XYe59FebeV2HufRXm3lfZsm0yxuf3DOWYQzdWYsba8ZZPJT5/eKqpG0uZsYwZqzJjNWKs8s9vBLxWistWuokuNV0r1VD+/PKSQvvXq0uKoXuqMzOWMGOVDbFK0GesIvlrrH9/ccrt6ZMk8fXL9frOyHLX3r6tHcxBh+qgQzu/w137Ebd2iA46JAcdsoMO4qCDA09HB56ODjwdHXg6nuXp1uuQzvJ0v8NZnu53OMvT/Q5nebrf4SxP9zuc5el+h92e1r90uGLtVu8g1g6bioYrlsnkv3gqzx+d0pcXf/0v3s7vkIODDtFBh+SgQ3bQQRx0KA46qIMO5qCDA09nB54WB54WB54WB54WB56+a7/41g4OPC0OPC0OPC0OPC0OPF0ceLo48HRx4OniwNN37fjf2sGBp4sDTxcHni4OPF0ceFodeFodeFodeFodePqumQ1bOzjwtDrwtDrwtDrwtDrwtDnwtDnwtDnwtDnw9F1TN7Z2cOBpc+Bpc+Bpc+Bpc+Dp6sDT1YGnqwNPVweevmtuytYODjxdHXi6OvB0deDp6sDTzYGnmwNPNweebg483Rx4ujnwdHPg6ebA082Bp9v5ntZwvqc1nO9pDed7WsP5ntZwvqc1nO9pDed7WsP5ntZwvqc1OPB0dODp6MDT0YGnowNPb5kadncHB56ODjwdHXg6OvB0dODp5MDTyYGnkwNPJwee3jI17O4ODjydHHg6OfC0g3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGpg3lk6mAemTqYR6YO5pGZg3lk5mAemTmYR2YO5pFZON/T5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pGZg3lk5mAemTmYR2YO5pFVB/PIqoN5ZNXBPLLqYB5ZDed7ujqYR1YdzCOrDuaRVQfzyKqDeWTVwTyy6mAeWXUwj6w6mEdWHcwjqw7mkVUH88iqg3lk1cE8supgHll1MI+sOphHVh3MI6sO5pFVB/PIqoN5ZNXBPLLqYB5ZdTCPrDqYR1YdzCOrW2ZIlfb84UVz+drhilWYsXb85tVy/RdvMXRjNWSsLXOA3ogVmbESM9Y/fgF5rSTLVirLVtJlK9myleqyldqqlf75USjXSnHZSmnZSrcwQoOV50oaQ/zzy7PF+PzhFlMPXffM87g/VmHGUmYsY8aqzFgNGeueCRb3x4rMWIkZi0l5ZVJemZRXJuWVSXllUl6ZlDcm5Y1JeWNS3piUNybljUl5Y1LemJQ3JuWNSfnKpHxlUr4yKV+ZlK9Mylcm5SuT8pVJ+cqkfGVSvjEp35iUb0zKNyblG5PyjUn5xqR8Y1K+MSnfkJRvAUn5FpCUbwFJ+RaQlG8BSfkWkJRvAUn5FpCUbwFJ+RaYlI9Mykcm5SOT8pFJ+cikfGRSPjIpH5mUj0zKRyblE5PyaQcgakzXD8/9WIUZa8dbvsr1w1st3VgNGSsHZqzIjJWYsf7xC5trJVm20j10SXZ99Prx79xdSZetZMtWqstWaqtWumcv1FsrxWUrpWUr5WUrybKVljFCljFCljFCljFCljGiLGNEWcaIsowRZRkjyjJGlGWMKMsYUZYxoixjRFnGCF3GCF3GCF3GCF3GCF3GCF3GCF3GCF3GCF3GCF3GCFvGCFvGCFvGCFvGCFvGCFvGCFvGCFvGCFvGCFvGiLqMEXUZI+oyRtRljKjLGFGXMaIuY0Rdxoi6jBF1GSPaMka0ZYxoyxjRljGiLWNEW8aItowRbRkj2jJGtEWMKCGEZSvFZSulZSvdw4hscq2UrXRXkmUrlWUr6bKVbNlKddlKbdVKN33+9J2V4rKV0rKVljEiLmNEXMaIuIwRcRkj4jJGxGWMSMsYkZYxIi1jRFrGiLSMEWkZI9IyRqRljEjLGJGWMSIvY0Rexoi8jBF5GSPyMkbkZYzIyxiRlzEiL2NEXsYIWcYIWcYIWcYIWcYIWcYIWcYIWcYIWcYIWcYIWcaIsowRZRkjyjJGlGWMKMsYUZYxoixjRFnGiLKMEWUZI3QZI3QZI3QZI3QZI3QZI3QZI3QZI3QZI3QZI3QZI276pKCEfK0kQboryaqVbvpcWNHXHsliobtSXLbSPWevhXit1KT7PPemz1C9s5IuW8mWrVSXrXQLIyxc0w8e/y7655fnh6ueP/whk9eLwxXrng9c3R8rMmMlZqzMjCXMWIUZS5mxjBmrMmMhKR8DkvIxICkfA5LyMSApHwOS8jEgKR8DkvIxICkfA5LyMTApH5mUj0zKRyblI5PykUn5yKR8ZFI+MikfmZSPTMonJuUTk/KJSfnEpHxiUj4xKZ+YlE9Myicm5ROT8plJ+cykfGZSPjMpn5mUz0zKZyblM5PymUn5zKS8MCkvTMoLk/LCpLwwKS9MyguT8sKkvDApL0zKFyblC5PyhUn5wqR8YVK+MClfmJQvTMoXJuULk/LKpLwyKa9MyiuT8sqkvDIpr0zKK5PyyqS8MilvTMobk/LGpLwxKW9MyhuT8sakvDEpb0zKG5PylUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSXnm3tfI3PsamXtfI3Pva2TufY3Mva+Rufc1Mve+Rube18jc+xqZe18Tc+9rYu59Tcy9r4m59zUFJOUTc+9rYu59Tcy9r4m59zUx974m5t7XtGXbZIzh+cNjDt1YhRlrx1s+leerc6qpG6shY23ZCPhGrMiMlZix/vELm2slWbbSTXRpr5Vi+D6L79qud3csY8aqzFgNGeuu7Xp3x4rMWIkZKzNjCTMWk/KZSfnMpHxmUj4zKS9MyguT8sKkvDApL0zKC5PywqS8MCkvTMoLk/KFSfnCpHxhUr4wKV+YlC9Myhcm5QuT8oVJ+cKkvDIpr0zKK5PyyqS8MimvTMork/LKpLwyKa9MyhuT8sakvDEpb0zKG5PyxqS8MSlvTMobk/LGpHxlUr4yKV+ZlK9Mylcm5SuT8pVJ+cqkfGVSvjIp35iUb0zKNyblG5PyjUn5xqR8Y1K+MSnfmJRvSMrngKR8DkjK54CkfA5IyueApHwOSMrngKR8DkjK54CkfA5Mykcm5SOT8pFJ+cikfGRSPjIpH5mUj0zKRyblI5PyiUn5xKR8YlI+MSmfmJRn7n3NzL2vmbn3NTP3vmbm3tfM3PuamXtfM3Pva2bufc3Mva+Zufc1M/e+Zube18zc+5qZe18zc+9rZu59zcy9r5m59zUz975m5t7XzNz7mrdsm5zOFMtbtk2+EWvHW346jipv2Qj4RixlxjJmrMqM9Y9f2DxX+uf39l0r3UOXmPW1ktY/v1y05H+9WrTW3qm+abve7bEyM5YwY5X1sR62enr+8c+u52/arnd7LGPGqsxYDRnrpu16t8eKzFiJGSszYwkzFpPyxqS8MSlvTMobk/KVSfnKpHxlUr4yKV+ZlK9Mylcm5SuT8pVJ+cqkfGNSvjEp35iUb0zKNyblG5PyjUn5xqR8Y1K+ISkvAUl5CUjKS0BSXgKS8hKQlJeApLwEJOUlICkvAUl5CUzKRyblI5PykUn5yKR8ZFI+MikfmZSPTMpHJuUjk/KJSfnEpHxiUj4xKZ+YlE9Myicm5ROT8olJ+cSkfGZSPjMpn5mUz0zKZyblM5PymUn5zKR8ZlI+MykvTMoLk/LCpLwwKS9MyguT8sKkvDApL0zKC5PyhUn5wqR8YVK+MClfmJQvTMoXJuULk/KFSfnCpLwyKa9MyiuT8sqkvDIpz9z7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva/C3PsqzL2vwtz7Ksy9r8Lc+yrMva+yZ++rhiuWxm6syozVkLH27H2dx9pC+aZXrGbdWIkZKzNjCTPWDkBIut7ykvtv+UaMVbZsBNRanrEstG6szIwlzFiFGUuZsYwZqzJjNWSsLRsB34j1j1/YXCulZSvlZSvJspXKspV02Uq2bKW6bKW2aqV/fs/ZtdJNjLB2rZS+0qj38mrhOUK6Wso9dN21jezuWJkZS5ixCjOWMmMZM1ZlxmrIWHkDICReP1yi9WMJM9aGt/zjLsTzullS91tISq7MWA0Z6649NXfHisxYacdvYsuvWH+58/bvL05ZnklSLq9f21JfHbKDDoLvYOXqUEO3Q3HQQR10MHyH9rz1niSmbofqoEM7v0MJDjpEBx34np534Ht63oHv6XkHvqfnHfienndw4OniwNPFgaf1LE+3boezPN3vcJan+x3O8nS/w1me7nc4y9P9Djs8/bjJcnUw/T5bzUGH6qBDO7+DBQcdooMOyUGH7KCDOOhQHHRw4Glz4Glz4Gk7y9Pd69Z6lqf7Hc7ydL/DWZ7udzjL0/0OZ3m632H339PW25NV6g7ky+uTIdL/ZEhtyFgtMGNFZqzEjLWDiPn1myg3fGKniYMOBd9h+mmXpg46mIMOFd9h+pdLa8d30BAcdIgOOiQHHfiennfge3rege/peQe+p+cd+J6edzjf0xoceDo68HQ8y9Ot2+EsT/c7nOXpfoezPN3vcJan+x3O8nS/ww5PyzXdQOSvd3o/Y2t10KGd3yEFBx2igw7JQYfsoIM46FAcdFAHHRx4OjnwdHLg6XyWp7vXrfksT/c7nOXpfoezPN3vcJan+x3O8nS/w+6/p61+7XDF2n0rexBr993pfizZfaNzEGv3vctBrN23IwexhBlr903DQSzob+LuRz/9WGX305xBLCa3tk8C6X4SV7cP9xjEQn5uWQvzCmLLRIrHU/VnrMdNjW6shoy1ZV7B4/f/imXh71xhd//y3zKv4O4O4qBDcdBBHXQwBx2qgw7t/A5b5hXc3SE66ODA0+bA01vmFdzdwYGn7SxPd+8M21me7nc4y9P9Dmd5utuhnuXpfoezPN3vsMXTJleHWr/N1i3zCu7uIA46FAcd1EEHc9ChOujQzu+wZXzF3R2igw4OPN0ceHrLFI27O5zl6e51azvL0/0OZ3m63+EsT/c7nOXpXgcLZ3m632H339O194Dewu5b2YNYwoz1jwPhWqmtWumf3/p+rRSXrZSWrXTPZV/K9lpJ5dtv1Jv2b98eqzBjKTOWrY8Vc3hq7/HP0o1VmbEaMtZNO5ZvjxWZsRIzVmbGEmaswoylzFhMyicm5ROT8plJ+cykfGZSPjMpn5mUz0zKZyblM5PymUn5zKS8MCkvTMoLk/LCpLwwKS9MyguT8sKkvDApL0zKFyblC5PyhUn5wqR8YVK+MClfmJQvTMoXJuULk/LKpLwyKa9MyiuT8sqkvDIpr0zKK5PyyqS8MilvTMobk/LGpLwxKW9MyhuT8sakvDEpb0zKG5PylUn5yqR8ZVK+MilfmZSvTMpXJuUrk/KVSfnKpHxjUr4xKd+YlG9Myjcm5RuT8o1J+cakfGNSviEpXwOS8jUgKV8DkvI1IClfA5LyNSApXwOS8jUgKV8DkvI1MCkfmZSPTMpHJuUjk/KRSfnIpHxkUp6597Uy975W5t7Xytz7Wpl7Xytz72tl7n2tzL2vlbn3tTL3vlbm3tfK3PtamXtfK3Pva2Xufa3Mva+Vufe1Mve+Vube18rc+1qZe18rc+9r3bP3VcMVS2Mv1p69r/NYkRkrMWNtoXzTK1azbixhxirMWIqMtWXbpKTrLS+5+5bfsm3yjVg73vJayzOWfR1n+CVWYcZSZixjxqrMWA0Za8tGwDdiRWasxIz1j1/YXCvJspXKspV02Uq2bKW6bKW2aqW7drNdk80f/271zy+fjzavd+1muztWYsbKzFjCjFWYsZQZy9bHqqE97fz4p/bsfNdutrtjNWSsuoHyNabn3/c1Su3GisxYiRkrM2MJM1ZhxlJmLGPGqsxYDRmrMSnfmJRvTMo3JuXbbsqX7j3vtpvyg1i7KT+ItZvyg1i7KT+ItZvy3Vgt7KZ8Kd1Yuyk/iLWb8oNYuyk/iLWd8v1Y2ynfj7Wd8v1Y2ynfj7WF8pavWDV1YzVkrBiYsXZQPoXr/laK2o2VmLG2UL7VVyzrxhJmrMKMpcxYxoy1g/Ip2RVLWjdWQ8ZKYXOs0qV8isxYiRkrM2MJM1ZhxlJmLGPG2k35QazdlO/HykzKZyblM5PymUn5zKR8ZlI+MymfmZTPTMpnJuWFSXlhUl6YlBcm5YVJeWFSXpiUFyblhUl5Yd6xKbspP4i1m/KDWLspP4i1m/KDWLspP4i1m/KDWLspP4i1m/KDWMz78oVJeWVSXpmUVybllUl5ZVJemZRXJuWVSXllUl6ZlDcm5Y1JeWNS3piUNybljUl5Y1LemJQ3JuWNSfnKpHxlUr4yKV+ZlK9Mylcm5SuT8pVJ+cqkfGVSvjEpv2XbZKrhilW7e8i2bJucxdKwZQ+ZvKZnlKDdWIkZa8d/RAvxGctS7sZSZixjxqrMWA0Za8uuqDdiRWasxIyVmbGEGYtJ+cik/D+//ehaqa1a6Z/fJHStFJetlJatdA9tcm7XSln1zy9PIs9cj3+W3hv1pt05t8cqzFjKjGXMWJUZqyFj3bQ75/ZYkRkrMWMxKZ+ZlM9Mymcm5TOT8plJ+cykvDApL0zKC5PywqS8MCkvTMoLk/JlByBKeg5cevxTurEiM9Y//pa/VirLVtJlK9myleqylW7yfkvXSpLCt3+tb/ok/+2xIjNWYsbKzFjCjFWYsZQZy5ixKjMWk/LGpLwxKW9MyhuT8sakvDEpb0zKG5PyxqS8MSlfmZSvTMpXJuXrDkDMb2hUQ8ZqO97y5fprP5Xet8E8YkVmrMSMlZmxhBnrH7+wuVbSZSv9fbpch9bPD22fHho/+JKZ69ABG5rG16HWPzR9fmj+/FD5/NDy+aH6+aH2+aH180Pbx4eOPrb9zqGfv5vi5++mWIlXAzE2ZKwUmLEiM1ZixtpykaKvWFq7sYQZqzBjKTOWMWNVZqyGjJUDM1ZkxtpC+RJfsf6yH7nz4izPJCmX12aaUl8dsoMOgu9g5epQQ7dDcdBBHXQwfIcWrtuvMXU7VAcd2vkdJDjoEB104Ht63oHv6XkHvqfnHfiennfge3rewYGnxYGnxYGny1mebt0OZ3m63+EsT/c7nOXpfoezPN3vcJan+x12e9q6t73KFvW260NHGnI3VmXGashYW/bMvBErMmNtMVNNr1gyo8n0LumWDTZ/r8P07tyW3Th3dygOOii+w/Sqf8umoLs7VAcd2vkdtuxNurtDdNCB7+l5B76n5x34np534Ht63sGBp82Bp82Bp+0sT3fvqNSzPN3vcJan+x3O8nS/w1me7nc4y9P9Drs9Hbu3jOpu9Sbtxtpt00GszY9CNVk31hbnzbbPReaO0cjcMRqZO0Yjc8doZO4Yja0wYykzljFjVWYsJOVTQFI+BSTlU0BSPgUk5VNAUj4FJOVTQFI+BSTlU0BSPgUm5SOT8pFJ+cikfGRSPjIpH5mUj0zKRyblI5PykUn5xKR8YlI+MSmfmJRPTMonJuUTk/JbvjhtOjEmZeQ3ZqSM/MaMtOWL096IlZmxZEes2VSPtOWL096IpcxYxoxVmbEaMtaWL057I1ZkxkrMWFsof+skn7TlW9bu7lDwHWb7O9KW72+7u4M56FDxHWafG03Szu+w54sDb+4QHXRIDjrwPT3vwPf0vAPf0/MOfE/PO/A9Pe/gwNPFgafVgaf1LE+3boezPN3vcJan+x3O8nS/w1me7nc4y9P9Drs93Z1GlHSLemcTY5I2ZCwLzFiRGSsxY20x063TiNJdEwL+wQ7Tu3NWHHRQBx0M32F61W/VQYd2focaHHSIDjokBx34np534Ht63oHv6XkHvqfnHRx4ujrwdHXg6XaWp7t3VNpZnu53OMvT/Q5nebrf4SxP9zuc5el+h92e7k4jSm23ertjf1LbbdNBrM2PQvvTiHLY4rzZ1pUcIjNWYsbKzFjCjFWYsZQZy5ixKjNWQ8aKTMpHJuUjk/KRSfnIpHxkUj4yKR+ZlI9Mykcm5ROT8olJ+cSkfGJSPjEpn5iUT0zKJyblE5PyiUn5zKR8ZlI+MymfmZTPTMpnJuUzk/KZSfmbZgkkkyvW417/n19eS36OOHj8U7qxhBnLNsSy8HxcUC3lbqzKjNWQsW7a4n17rMiMxfxNvGlP7+2xlBnLmLEqM9YObhVLV6zWjaWBGSsyYyVmrMyMJcxYhRlLmbGMGasyYzEpb0zKG5Pytp3y3c9v2XbK92Ntp3w/1nbK92Ntp3w/1nbK92Ntp3w/1mbKayi9WDUwY0VmrMSMlZmxhBmrMGPtoLzm67abSujGMmasyoy1g/Jqr1g19WK1wIy1g/Kq8orVvdPcEjNWZsbaQfk3YhVmLGXGMmasyozViLEkBGYs5PNECYkZKzNjCTNWYcZSZizkp0YkID81IgH5qRGJyE+NSGRSPjIpH5mUj9spr91Y2ynfj7Wd8v1Y2ynfj7Wd8v1Y2ynfjZW2U74fazvl+7G2U74fazvl+7GYlE9Myicm5ROT8olJ+cSkfGZSPjMpn5mUz0zKZyblM5PymUn5zKR8ZlI+MykvTMoLk/LCpLwwKS9MyguT8sKk/P7dnP1YzPvyzN2cwtzNKczdnFKY9+UL87582U75fizm09fCfPpamE9fC5PyhUl5ZVJemZRXJuWVSXllUl6ZlFcm5ZVJeWVSXpmUNybljUl5Y1LemJQ3JuWNSXljUt6YlDcm5Y1J+cqkfGVSvjIpX5mUr0zKVyblK5PylUn5yqR8ZVJ+y27OVJ/f2vb4Z+zGysxYwoxVmLGUGWsHt3Isz1g5WzdWZcZqxFhly27ON2JFZqzEjJWZsYQZqzBjKTMWkvIlIClfApPykUn5uJvy3fE6Je6m/CDWbsoPYu2m/CDWbsoPYu2m/CDWbsoPYu2mfPdbRErcTfl+rLSb8oNY2ynfj7Wd8v1Y2ynfj7Wd8v1YWyhv162RbK0bS5mxjBlrB+Ul6DOWxO7V6ZbdnPNYW3Zz5tZesbq/iVt2c74RKzFjZWYsYcYqzFjKjGXMWJUZqyFjbdnNKfkaHy1FurEiM1ZixsrMWMKMVZixlBnLmLEqM1ZDxipMyhcm5QuT8mU75bt/J5btlO/H2k75fqztlO/H2k75fqztlO/H2k75bizdTvl+rO2U78faTvl+LCbllUl5ZVJemZRXJuWVSXllUt6YlDcm5Y1JeWNS3piUNybljUl5Y1LemJQ3JuUrk/KVSfnKpHxlUr4yKV+ZlK9MylfmffnKvC9fmfflG/O+fGPel2/M+/KN+fS1bad8Pxbz6WtjPn1tTMo3JuUbkvIakJTXgKS8BiTlNSAprwFJeQ1IymtAUl4DkvIakJTXwKR8ZFI+MikfmZSPTMpHJuUjk/KRSfnIpHxkUj4yKZ+YlE9Myicm5ROT8olJ+cSkfGJSPjEpn5iUv2sjYLZXLJ28PMr1wx//bN1YhRmrboil9bk5Plrox2rIWHdtbbs7VmTGSsxYW34T63PbZCyhdmMpM5YxY1VmrIaMVQIzVmTGSsxYmRlLmLGYlC9Myhcm5ctuysfYjbWb8v1Yupvyg1i7KT+ItZvyg1i7KT+ItZvyg1i7Kd/9SgXV3ZQfxNpN+UGs3ZQfxNpB+ZLsiiXdP18tMGNFZqzEjJWZsYQZqzBjKTOWMWNVZiwm5SuT8pVJ+bqb8iV1Y+2m/CDWbsoPYu2m/CDWbsoPYu2m/CDWnmv5Oou1547N62xp70sCtAVmrC2Uf/1BpqH7x35LzFg7KK/hesypybqxhBlrC+VfgNDcf8srM5YxY1VmrC2fGsn5itWVj4XAjBU3/0cspRsrMWNlZixhxtpN+UGs3ZRX68baTflBrN2UH8RqyFgxMGPtpvwg1m7KD2Ltpvwg1m7KD2LtoPz0A54WlRnLmLGQnwC3iPwEuCXkJ8AtIT8Bbgn5CXBLmRlLmLGYlE9Myicm5dNuysfuPYi0m/L9WHk35QexdlN+EGs35QexdlN+EGs35QexdlN+EGs35QexdlN+EItJ+e27Ofuxtu/mHMRiUn77bs5BLCblhUl5YVJemJQXJuWFSXlhUr4wKV+YlC9Myhcm5QuT8oVJ+cKkfGFSvjApX5iUVybllUl5Zd6XV+Z9ed1N+UEs5n15Zd6XV+Z9eWU+fVXm01djPn015tNXY1LemJQ3JuWNSXljUt6YlDcm5Y1J+cqkfGVSvjIpX5mUr0zKVyblK5PylUn5yqR8ZVK+MSnfmJRvTMo3JuUbk/KNSfnGpHxjUr4xKd+QlK8BSfkakJSvAUn5GpCUrwFJ+XrTRsCY9Yr1WHUSa/pND/WmjYC3x5INsd74j1iYsZQZy5ixKjJW2vKbOBu2XW/arHV7rMyMJcxYhRlLmbGMGasyYzVkrByYsZiUz0zKZybl827Kd8fe17yb8oNYuyk/iLWb8oNYuyk/iLWb8v1Yspvyg1i7Kd/97oIquyk/iLWb8oNYuyk/iLWD8tNh21WUGcuYsSozVkPGKoEZKzJjJWaszIwlzFhMyhcm5QuT8mU35bsjfmvZTfl+LN1N+UGs3ZQfxNpN+UGs3ZQfxNpzLV9nsfbcsXmdLQ3dWMqMtYXys296qFqZsXZQfvpND9UCM9YWys++u6BaYsbKzFjCjLXlUyOzb3qopsxYtvk/YvdLAqpVZqyGjFUDM9Zuyg9i7aZ8d5B7rbspP4i1m/KDWIUZS5mxdlN+EGs35QexdlO+H6vtpvwg1g7Kzz/g2RIzVmbGEmYs5ifAG/MT4I35CfDG/AR4a8RYLQRmLCTlW0BSvgUk5VvYTfnuJLwWdlN+EGs35QexdlN+EGs35QexdlO+Hyvupvwg1m7KD2Ltpvwg1m7KD2IxKb99N+cgFpPy23dzDmIxKR+ZlE9Myicm5ROT8olJ+cSkfGJSPjEpn5iUT0zKJyblM5PymUn5zKR8ZlI+MymfmZTPTMpnJuUz8r58y8z78sK8Ly/M+/LCvC8vzPvyspvyg1jIp69NkE9fmyCfvjZhUl6YlC9Myhcm5QuT8oVJ+cKkfGFSvjApX5iUL0zKFybllUl5ZVJemZRXJuWVSXllUl6ZlFcm5ZVJeWVS3piUNybljUl5Y1LemJQ3JuWNSXljUt6YlDcm5SuT8jft5gwtvmIF/fPLc7yGeuTY/rL39d9fnLI8k6RcXrMPS311EAcdCr6DlatDDd0O6qCDOehQ8R1aeHaQLw99v3Zo53e4aSPs3g7RQYfkoAPf0/MOfE/PO/A9Pe/A9/S8A9/T8w4OPN2O97SFcLynHx3O8nTrdjjL0/0OZ3m63+EsT/c7nOXpfoezPN3vsMXTGl8d9M8d4qPE8x5ZKl9enDovrpb+9doWXpn/8xs5/v3nxqrXz/3ynR2Pf17npv6em+G5ab/nZnRuYvg9N8NzE3/PzfDcpN9zMzw3+ffcDM+N/J6b4bkpv+dmeG7099wMz83vdfH43PxeF4/Pze918fDcpN/r4vG5+b0uHp+b3+vi8bn5vS4enxv5PTfDc/N7XTw+NwdfF18dDr5+vTrwrzNrujrU3O3Avx6cdsj867Z5B/711bwD/zpo3gF/vZLDxaUcQ7eDOOiA9/8bHfCenncQPFulXN/9JkW6HfBsfaMD/ne6RHl2KKV2O+B/p4tdvw+l9jvgf6ff6IC/9v76zaq562nBX3urvDp8/YK+Lx3w197zDgXvhzc64P3wRgf8tbfq67ulrculgr/2fqMD3tOq9epQu9caBe/pNzrs8HRK12cfU+7MIn3EMmasyozVkLE0MGNFZqzEjJWZsYQZa4cSUgyvWPZnJeRULn887vJ1O6iDDuagQ3XQoZ3fwYKDDtFBhwTvkF4vfvzz9efnl206lh10EHyHbFcH6W7jNLqn3+lA9/Q7HeieTqmkq4NJtwPd0+90oHv6jQ6V7ul3OtA9/U4HvqfnHfiennfge3rege/peQe+p+cdHHi6OvB0deDpdpSna+x2OMrTgw5HeXrQ4ShPDzoc5elBh6M8PehwlKcHHY7y9KDDUZ4edDjK090OMZzv6RjO93QM53s6hvM9HcP5no7hfE/HcL6nYzjf0zGc7+kYHHg6OvB0dODp6MDT0YGnt4zRuruDA09HB56ODjwdHXg6nn/fO6bzn0/HdP7z6ZjOfz4d0/nPp+OWsT53dzj/+XRM5z+fjun859Mxnf98OiYHns4OPJ0deDo78HR24OktY3Lu7uDA09mBp7MDT2cHns4OPC0OPC0OPC0OPC0OPL1l9NXdHRx4Whx4Whx4Whx4Whx4ujjwdHHg6eLA08WBp7eMvrq7gwNPFweeLg48vWeo1jUZLSf7S4crVkPG2jNUax4rMmMlZqwtGhtOWPlbL746iIMOBd5hPo4l7hnX9bc6zMaAxD3jum7uUB10aPgO08uJPeO6bu4QHXRIDjrQPf1OB7qn3+nA9/S8A9/T8w58T8878D097+DA09WBp6sDT9ejPN3fHlCP8vSgw1GeHnQ4ytODDkd5etDhKE8POhzl6UGHozzd79CO8vSgw1GeHnRw4OnmwNN7xnXd3MGBp5sDTzcHnm4OPN3O93QK53s6hfM9ncL5nk7hfE+ncL6nUzjf0ymc7+kUzvd0Cud7OgUHno4OPB3Pv++d4vnPp1M8//l02jOu6+YO5z+fTvH859Mpnv98OsXzn0+neP7z6ZTOfz6dkgNPJweeTg48vWdc180dHHg6OfB0cuDp5MDTyYGnswNPZweezg48nR14es+4rps7OPB0duDp7MDT2YGnswNPiwNPiwNPiwNPiwNP7xnXdXMHB54WB54WB54WB54WB54uDjxdHHi6OPB0ceDpPeO6bu7A8vQVi6XeKxbLplcsliCfsbZMfop6xYpN//z7EaXkf7348c8vQdKrQ8J3sFeHmrsdsoMO4qBDcdBBHXQwBx2qgw7t/A5bZkrd3YHv6XmHozzdQrcD39NNnh1K6F4vbZkpdXcHvqfnHfiennfge3rege/peQe+p6cdKt/T8w58T8878D097+DA01tmSt3dwYGnqwNPVweerg48XR14ujnwdHPg6ebA082Bp7fMlLq7gwNPNweebg483Rx4up3v6RzO93QO53s6h/M9ncP5ns7hfE/ncL6nczjf0zmc7+kczvd0Dg48HR14OjrwdHTg6ejA01tmSt3dwYGnowNPRweejg48HR14OjnwdHLg6eTA08mBp7fMlPqbn+dLsw4HfN572uGAz3tPOxzwee9phwM+7z3tcMDnvWcd8gGf9552OODz3tMOfE9rmXXge3rege/peQe+p+cd+J6ed+B7et4B7+mS49Uha7cD3tPzDoL39Bsd8J5+owPe0290wHu6pPzqYN0OeE+/0QHv6Tc64D39Rge8p9/owPf0vAPf09MOhe/peQe+p+cd+J7+0kG6197lAE+/7muU2u1wgKenHQ7w9LTDAZ6edjjA09MOB3h62uEAT8866AGennbgezrKrAPf0/MOfE/PO/A9Pe/A9/S8A9/T8w58T8878D0978D39LQDfx7ZGx1u8kN8dQhl2qHaq0P5c4f0uH30rxenx1+d14tfc3XzXXOwtnYo+A5Wrg41dDuogw7moEPFd2jh2UFi6nZo53e4aw7W1g7RQYfkoAPf0/MOfE/PO/A9Pe/A9/S8A9/T8w4OPF0deLo58HQ7y9Ot2+EsT/c7nOXpfoezPN3vcJan+x3O8nS/wxZP/517ZI8Sz3tkqfzlM4n//uJ67ZVoXz6SnHLv58aq189N+euLr3NTf8/N8Ny033MzODcSwu+5GZ6b+Htuhucm/Z6b4bnJv+dmeG7k99wMz035PTfDc6O/52Z4bn6vi8fn5ve6eHxufq+Lh+cm/l4Xj8/N73Xx+Nz8XhePz83vdfH43MjvuRmem9/r4vG5Ofi6+Opw8PXr1YF/nVmvfRap+12sEvnXg9MOiX/dNu/Av76ad+BfB8074K9Xcri4lGPodhAHHfD+f6MD3tPzDhnPVimv7+ou0u2AZ+sbHfC/09O9IpLxv9PFrt+HUvsd8L/Tb3TAX3truGa3ae56OuOvvVVeHUrpdsBfe887CN4Pb3TA++GNDvhrb9WLS2pdLgn+2vuNDnhPq9arQ+1eawje02902OHplK7PPqacvna4YhkzVmXGashYJTBjRWasxIyVmbGEGWuHElIMr1j2ZyXkVC5/PO7ydTuogw7moEN10KGd30GDgw7RQYcE75BeL3788/Xn52ubjmh20EHwHbJdHSR1O9A9/U4Huqff6UD3dEolXR1Muh3onn6nA93Tb3Qwuqff6UD39Dsd+J6ed+B7et6B7+l5B76n5x34np53cOBpc+Bpc+DpepSna+x2OMrTgw5HeXrQ4ShPDzoc5elBh6M8PehwlKcHHY7y9KDDUZ4edDjK0/0OzYGnmwNPNweebg48vWVc290dHHi6OfB0c+Dp5sDT7XxPl3C+p0s439MlnO/pEs73dAnne7qE8z1dwvmeLuF8T5dwvqdLOP++d4nnP58u8fzn0yWe/3y6xPOfT5ctY33u7nD+8+kSz38+XeL5z6dLPP/5dIkOPJ0ceDo58HRy4OnkwNNbxuTc3cGBp5MDTycHnk4OPJ0ceDo78HR24OnswNPZgae3jL66u4MDT2cHns4OPJ0deDo78LQ48LQ48LQ48LQ48PSW0Vd3d3DgaXHgaXHg6T1Dta7JaDnZXzpcsRoy1p6hWvNYkRkrMWNt0dhwwsrfevHVQRx0KPAO83EsZc+4rr/VYTYGpOwZ13Vzh+qgQ8N3mF5O7BnXdXOH6KBDctCB7ul3OtA9/U4HvqfnHfiennfge3rege/peQcHnjYHnjYHnrajPN3fHmBHeXrQ4ShPDzoc5elBh6M8PehwlKcHHY7y9KDDUZ7ud6hHeXrQ4ShPDzo48HR14Ok947pu7uDA09WBp6sDT1cHnq4OPN0ceLo58HRz4OnmwNN7xnXd3MGBp5sDTzcHnm4OPN3O97SG8z2t4fz73hrOfz6t4fzn0xqO8vSgw/nPpzWc/3xaw/nPpzWc/3xaw/nPpzWe/3xaowNPRweejg48vWdc180dHHg6OvB0dODp6MDT0YGnkwNPJweeTg48nRx4es+4rps7OPB0cuDp5MDTyYGnkwNPZweezg48nR14Ojvw9J5xXTd3cODp7MDT2YGnswNPZweeFgeeFgeeFgeeFgee3jOu6+YOLE9fsVjqvWKxbHrFYgnyGWvL5KeoV6zY9M+/H1FK/teLH//8EiS9OiR8B3t1qLnbITvoIA46FAcd1EEHc9ChOujQzu+wZabU3R34np53OMrTLXQ78D3d5NmhhO710paZUnd34Ht63oHv6XkHvqfnHfiennfge3rawfiennfge3rege/peQcHnt4yU+ruDg48bQ48bQ48bQ48bQ48XR14ujrwdHXg6erA01tmSt3dwYGnqwNPVweerg48XR14ujnwdHPg6ebA082Bp7fMlLq7gwNPNweebg483Rx4up3vaQvne9rC+Z62cL6nLZzvaQvne9rC+Z62cL6nLZzvaQvne9qCA09HB56ODjwdHXg6OvD0lplSf/PzfGnW4YDPe087HPB572mHAz7vPe1wwOe9px0O+Lz3rEM64PPe0w4HfN572oHvaS2zDnxPzzvwPT3vwPf0vAPf0/MOfE/PO+A9XXK8OmTtdsB7et4h4z39Rge8p9/ogPf0Gx3wni4pvzpYtwPe0290wHv6jQ54T7/RAe/pNzrwPT3vwPf0tIPwPT3vwPf0vAPf0186SPfaWw7w9Ou+RqndDgd4etrhAE9POxzg6WmHAzw97XCAp6cdDvD0rEM5wNPTDnxPR5l14Ht63oHv6XkHvqfnHfiennfge3rege/peQe+p+cd+J6eduDPI3ujwy1+0HI9rHn828LXl18rybKVyrKVdNlKtmylW+iimuRaSUv888tTlucPT7m8hs69hifbPYORbo91z6yjvxvLyhWrhm6syIyVmLHyjlgtPGNJTN1YwoxVmLGUGcuYsSozVkPGqoEZKzJjJWYsJuUrk/KVSfm6nfKtG2s75fuxtlO+H2s75bux2nbK92Ntp3w/1j2UL82+xEp/fnks+ryfYX8ZTf7vL63Xx9rbl0+Pptz7qbFePzal/PXFV9n8k8rKTypbflJZ/Ull7SeVrT+pbPs5Zes9U2VOKRt/UtkfdAVVww+6gqpBflLZH3QFVcMPuoKq4QddQdXwg66gavhJV1DxJ11BRdIV1BWKdKVzhdpwRZLC89M7KaRuKCGGKsRQSgxlxFAbzJbydf84x26oBgyVAjFUJIbagAS9vkFcS+mGUmKoDW90i88Xm0ovVN7wRn88Un6GatoNFYmhEjFUJoYSYqhCDKXEUEYMVYmhGjCUEIkuW4n+uDPZDbWF6M8PXzyuMbuhMjHUDqKbTkJtIPpDI89Q0n+jKzGUEUNVYqgGDFUCMVQkhkrEUJkYSoih9hK9/2d72UL0S8jWdV8xYqhKDNWAoTQQQ0ViqEQMlYmhdhA96SRUIYZSYqibNo5oukJZmLw8titVbPIaC/D6cH+9axP43bEaMtZdm8DvjhWZsRIzVmbGkvWxUorX478USzdWYcbSHbGyXbEkdWMZM1Zlxmo7YpV0xTLpxaqBGSsyYyVmrMyMJcxYhRlLmbGMGasyYzEp35iUb0zKt92Ur7EbazflB7F2U34QazflB7F2U34QazflB7F2U34Qazflu7Fa2E35QazdlB/EQlK+BSTlW0BSvgUk5VtAUr4FJOVbQFK+BSblI5PykUn5yKR8ZFI+MikfmZSPTMpHJuUjk/KRSfnEpHxC3rFpCXlfviXkffmWdlN+EAt5X74l5H35lpD35VtC3pdvCXlfvmXkffmWmZTPTMpnJuUzk/KZSfnMpHxmUj4zKZ+ZlBcm5YVJeWFSXpiUFyblhUl5YVJemJQXJuWFSfnCpHxhUr4wKV+YlC9Myhcm5QuT8oVJ+cKkfGFSXpmUVybllUl5ZVJemZS/ad/rayLwf/7bvr78WkmXrWTLVqrLVmqrVrppa+hfVqqlu1JcttI9v3yPu8HXSo/bZN2VyrKVdNlKtmylumyle36f2jXJ+PFvyX9++Wxrfbtpv97NoSIxVCKGysRQQgxViKF0fahYr4mGj3/2vrWy3bRH7/ZYdUOsFp+vfvxTu7EaMlYLzFhxR6zZBInWEjNWZsYSZqzCjKXMWMaMVZmxGjBWDSEwYxEp/4hFpPwjFpHyj1hEyj9iESn/iLWb8qV0Y+2m/CDWbsoPYu2mfD9W3E35QazdlB/E2k15/cvErs6LS3u+1l7bYvKXBruFMDixu4UwiLVbCINYTCFEphAiUwiRKYTEFEJiCiHtFsIgFpPyiUn5xKR8YlI+MSmfmJRPTMpnJuUzk/KZSfnMpHxmUj4zKZ+ZlM9Mymcm5TOT8sKkvDApL8xb+MK8hS+7KT+IxbyFL8QHtY9YxAe1j1jEB7WPWMwHtYX5oLYwH9QWJuULk/KFSfnCpHxhUr4wKV+YlC9MyiuT8sqkvDIpr0zKK5PyyqS8MimvTMork/LKpLwxKW9MyhuT8sakvDEpb0zKG5PyxqS8MSlvTMpXJuUrk/KVSfnKpHxlUr4yKf/P70e9VqrLVmqrVvrnN4JeK8VlK93z+1OaXStpSZOXl2vEw5dHk9du7keosiGUPXdNa5VuKCWGMmKoSgzVeKHiTZsObw4ViaESMVQmhhJiqL1Eb7kbagfRrxdbsG4oI4aqxFANGCoGYqhIDJWIoTIxlBBDFWIoItEjkeiRSPRIJHoiEj0RiZ6IRE9Eoici0ROR6IlI9EQkeiISPRGJnolEz0SiZyLRM5HomUj0TCR6JhI9E4meiUTPRKILkehCJLoQiS5EoguR6EIkuhCJLkSiC5HoQiR6IRK9EIleiEQvRKIXItELkeiFSPRCJHohEr0Qia5EoiuR6EokuhKJrkSiK5HoSiS6EomuRKIrkehGJLoRiW5EohuR6EYkuhGJbkSiG5HoRiS6EYleiUSvRKJXItErkeiVSPRKJHolEr0SiV6JRK9Eojci0RuR6I1I9EYkeiMSvRGJ3ohEb0SiNyLRG5DoKQCJngKQ6CkAiZ4CkOgpAImeApDoibhnNBH3jKYte0YtT0LtILrqn0Nt2TM6DRWJoTYQ3fJzG7lJ6IbKxFBCDFWIoZQYagPR7RofZRK7oSoxVAOG2rFndB4qEkMlYqhMDCXEUIUYSreGKl2ipy1EL89QKt1QO4gebRKqAUPt2DM6DxWJoRIxVCaGEmKoezglqV6hJNvXl18r1WUrtVUr3bQR8Z2V4rKVyrKVbnpHvOaLPn4fWneltmqlmzYyvbNSXLZSWrbSTe+9Wl7vvRa6K+mylWzZSnXZSjf9PrX0ekfE8ueXP/z5/OEpl9eEx9e863TTnpPbY8UdsaxcsWroxkrMWJkZS3bEauEZS2LqxirMWMqMZcxYlRmrIWNZYMaKzFiJGSszYzEpb0zKG5Pytp3yrRtrO+X7sbZTvhurbqd8P9Z2yvdjbad8P9ZN92Fj/XLnoP7Xzl+kd207eWOlsmwlXbaSLVupLlvpH+Baf6X2j9/z+/eX1+sBZLXuA8gWiaESMVQmhhJiqEIMpcRQtj5UrPX5MbPHP7s+bnVDrBafX0v3+Kd2YzVirBwCM1bcEWv2ZZM5JGaszIwlzFiFGUuZsYwZqzJjNWSsGJixmJSPTMpHJuUjk/KRSfm4m/Jfvp74a6zdlB/E2k35QazdlO/HSrspP4i1m/KDWLspr395sNN5cWnP19prU0D+0mC3EAYndrcQBrF2C2EQiymExBRCYgohMYWQmULITCHk3UIYxGJSPjMpn5mUz0zKZyblM5PymUl5YVJemJQXJuWFSXlhUl6YlBcm5YVJeWFSXpiUL0zKFyblC/MWfmHewi+7KT+IxbyFX5gPagvzQW1hPqgtzAe1ynxQq8wHtcqkvDIpr0zKK5PyyqS8MimvTMork/LGpLwxKW9MyhuT8sakvDEpb0zKG5PyxqS8MSlfmZSvTMpXJuUrk/KVSfnKpHxlUr4yKV+ZlK9Myjcm5RuT8o1J+cakfGNSvjEp/89vkr1WsmUr1WUrrRofKiEsW+meX+tgr2GRMcQ/v/whhOc44geEv4wuDq9YwoxVmLGUGcuYsSozVkPGumlf5O2xIjNW2hCrtvKKlb/G+vcXz+fUSswOOgi+w2zUrMTioIM66GD4DrNZiBKrgw7t/A4pOOgQHXTge3rege/peQe+p+cd+J6ed+B7et7BgaeTA08nB57OZ3m6dTuc5el+h7M83e9wlqf7Hc7ydL/DWZ7ud9jt6dS97ZW33OnN1w9vYt1YlRmrIWNJYMaKzFg7zPR6wpu/PuH99C6pZHyH6d25m7Zf7+1QHHRQfIfpVb+Ygw7VQYd2focSHHSIDjrwPT3vwPf0vAPf0/MOfE/POzjwdHHg6eLA0+UsT3fvqOhZnu53OMvT/Q5nebrf4SxP9zuc5el+h92eLt1bRrpbvV+/pOpLrN02HcTa/Sj0y0Txr7G2PN2U1+3IWv78+zHfBiIWHHSIDjokBx2ygw7ioENx0EHhHVKK17VHiqXbwfAdsl0dpPt3nVUHHeiefqNDpXs6pZKuDibdDnRPv9OB7ul3OtA9/U4Huqff6UD39Dsd+J6ed+B7et6B7+l5B76npx2aA083B55uDjzdjvJ0jd0OR3l60OEoTw86HOXpQYejPD3ocJSnBx2O8nS3QwlHeXrQ4ShPDzoc5elBh/M9XcL5ni7hfE+XcL6nSzjf0yWc7+kSHHg6OvB0dODp6MDT0YGn90yzurmDA09HB56ODjwdHXg6OvB0cuDp5MDT6fz73iWd/3y67JlmdXOH859Pl3T+8+mSzn8+XdL5z6dLOv/5dMnnP58u+fzn0yU78HR24Ok906xu7uDA09mBp7MDT2cHns4OPC0OPC0OPC0OPC0OPL1lttfdHRx4Whx4Whx4Whx4Whx4ujjwdHHg6eLA08WBp7fM9rq7gwNPFweeLg48XRx4ujjwtDrwtDrwtDrwtDrw9JbZXnd3cOBpZXn6isVS7xWLZdMrFkuQz1j3zJQqVp9vYi01lD+//PHOef7wx2lp3ViZGUuYsQozljJj2Y5Ymp+xLISJEqZfxVHuGbm0uUPDd5h9jUW5Z+TS5g7RQYeE7zAbj11qdtBBHHQoDjqogw58T8878D0978D39LRD43t63oHv6XkHB55uDjx9z8ilzR3O8nTrdjjL0/0OZ3m63+EsT/c7nOXpXgcNZ3m632GHpy2Xq4P+pcMVKzFj7bCpRXnFSn/+L/74e/D5X/xxCdbvIA46FAcd1EEHc9ChOujQzu8QA7zD/AsyNEZ8h9kXM2hMDjrQPf1OB7qn5x8G0Uj39Dsd6J5+pwPd0+90oHv6nQ50T7/RIfE9Pe/A9/S8A9/T8w58T887OPB0cuDp5MDT6ShPdwe2aTrK04MOR3m63yEf5elBh6M8PehwlKcHHY7y9KDDUZ4edDjK04MOR3l60MGBp7MDT2cHnhYHnhYHnhYHnhYHnr5nMNLmDg48LQ48LQ48LQ48LQ48XRx4ujjwdHHg6eLA0/cMRtrcwYGni4P73sXB8+ni4Pl0cfB8Wh08n1YHz6fVwfNpdfB8+p7BSJs7OHg+rQ48rQ48rQ48rQ48bQ48bQ48bQ48bQ48vWVc190dHHjaHHjaHHjaHHjaHHi6OvB0deDp6sDT1YGnt0wNu7uDA09XB56uDjxdHXi6OvB0c+Dp5sDTzYGnmwNPb5kadneHLZ5u11DqmurXDlcsZcbaYtNmV6ys3ViVGWuH8x5/El+xLHVi2ZahWm/EisxYiRkrM2PtUEK1Swm12UQJ00H0tmX01d/rMBuAbltGX93dwRx0qPgOs8GqtmX01c0dtoy+urtDdNAhOeiQHXTge3rege/peQe+p+cd+J6ed3Dg6ejA08mBp9NZnm7dDmd5ut/hLE/3O5zl6X6Hszzd73CWp/sdNnu6hd73L1qqzFgNGSsHZqwtzhtOvP5bL746JAcdMrzD/JGcbRkjdXeHclKH7rZX2zJG6u4O5qBDddChnd9hyxipuzvQPf1OB7qn3+lwlKcHHY7y9KCDA0+LA0+LA0+LA0+LA08XB54uDjxdHHi6OPD0ljFSd3dw4OniwNPFgaeLA08XB55WB55WB55WB55WB57eMkbq5vveepSnBx2O8vSgw1GeHnQ4ytODDkd5ut/BjvL0oMNRnh50OMrTgw4Onk9vGSN1dwcHnjYHnjYHnjYHnjYHnq4OPF0deLo68HR14OktY6Tu7uDA09WBp6sDT1cHnq4OPN0ceLo58HRz4OnmwNNbxkjd3cGBp5sDTzcHnm4OPN3O93QN53u6hvM9XcP5nq7hfE/XcL6nazjf0zWc7+kazvd0DSxPX7FY6n3GiiybXrFYgrxi3cTanK9Y9mXaYfflOdbneMccW5n8fkznKNa75jNt7aD4DrMZhPWu+UxbO1QHHRq+w2y2Ub1rPtPWDtFBh+SgQ3bQge/peQe+p+cd+J6ed+B7et6B7+l5Bweezg48nR14Op/l6dbtcJan+x3O8nS/w1me7nc4y9P9Dmd5ut9hi6c1vjronzvER4l/vTim8uXFqfPias+7by28Mqfc+7mx6vVzU/764uvctN9zMzo3En7PzfDcxN9zMzw36ffcDM9N/j03w3Mjv+dmeG7K77kZnhv9PTfDc2O/52Z4bn6vi8fn5ve6eHhuyu918fjc/F4Xj8/N73Xx+Nz8XhePz438npvhufm9Lh6fm9/r4vG5Ofi6+Opw8PXr1YF/nXl92vPxz9zroPzrwXkH/nXbvAP/+mregX8dNO8g9A45XFzKXz+T/aUD/rrijQ54/7/RAe/peQfDs1XK80c//indDni2vtEB/ztd4vO792J5PMDvdcD/The7fh9K7XfA/06/0QF/7a3huUchau562vDX3iqvDqX0OlT8tfcbHfB+eKMD3g9vdMBfe6teXFLrcumuOWhbO+A9rVqvDrV7rVHxnn6jww5Pp3R99jHl/197X7QrO64r90eBSIqk9Dk3QR4uENwEyU2APOTfswY5y92TI4+82R66pLXf9mC6VlV101Vu2Vbzu4dDVsOU1SFl9YIpizBlMaYswZRVMWUppqwnKoGpvGT5X1fCha0Kum/goW3goS/voZeygQfawANv4EHAPfDrxV//fH39fD2m83VVewMPCu9B/PBQeegBvaeveEDv6Sse0Ht6vm1YL+g9fcEDoff0FQ/oPX3FA3pPX/GA39NzD/g9PfeA39NzD/g9PfeA39NzDxv0NG3Q07xBT/NSPT38ad/OS/X0iYelevrEw1I9feJhqZ4+8bBUT594WKqnTzws1dMnHpbq6bEHWaqnTzxs0NOyQU/LBj39yHZtd3vYoKdlg56WDXpaNuhp2aCn6wY9XTfo6bpBT9cNevqR7bnu9rBBT9cNerpu0NN1g56uG/S0brDurRtcn9YNrk/rBtenH9ku6G4PG1yf1g2uT+sG16d1g+vTusH1adugp22DnrYNeto26OlHtsm528MGPW0b9LRt0NO2QU/bBj3tG/S0b9DTvkFP+wY97Rv0tG/Q075BT/sGPe0b9LRv0NNtg55uG/R026Cn2wY9/cjWV3d72KCn2wY93Tbo6bZBTz+zqdaxM5qw/8nDt6xnNtWayyJMWYwpSzBlPVJjeuwcyI3/+rC9sB3LMztw3ezBwD1c2I7lme26fsnDdBuQZ7brutlDX91DL89s1/VLHianE18eaAMPvIEH2cADek9f8YDe01c84Pf03AN+T8894Pf03AN+T0890AY9TRv0NG3Q07RUT48eD/jysFRPn3hYqqdPPCzV0ycelurpEw9L9fSJh6V6euyBl+rpEw9L9fSJh6V6+sTDBj39zHZdN3vYoKd5g57mDXqaN+hp3qCnZYOelg16Wjboadmgp5/ZrutmDxv0tGzQ07JBT8sGPS0b9HTdoKfrBj1dN1j3rhtcn35mu66bPWxwfbpucH26bnB9um5wfbpucH1aN7g+rRtcn9YNelo36Olntuu62cMGPa0b9LRu0NO6QU/rBj1tG/S0bdDTtkFP2wY9/cx2XTd72KCnbYOetg162jboadugp32DnvYNeto36GnfoKef2a7rZg8b9LRv0NO+QU/7Bj3tG/R026Cn2wY93Tbo6bZBTz+zXdfNHjbo6YbV04csrOo9ZGG16SELqyC/ZT2y8xPZIYu6/fXxQVW///TXP9+E8MuDwHvwl4cmQw91Aw+6gQfbwINv4KFt4KEv74Ee2VPqbg+0gQf8np57WKqnexl6wO/pXr89aKlDD/g9PfeA39NzD/g9PfeA39NzD/g9PfVA+D0994Df03MP+D0994Df03MPG/Q0bdDTtEFP0wY9TRv0NG3Q07xBT/MGPc0b9DRv0NOP7Cl1t4cNepo36GneoKd5g57mDXpaNuhp2aCnZYOelg16+pE9pe72sEFPywY9LRv0tGzQ07JBT9cNerpu0NN1g56uG/T0I3tK3e1hg56uG/R03aCn6wY9XTfoad2gp3WDntYNelo36OlH9pS628MC93vzzMMC93tPPSxwv/fUwwL3e089LHC/98yDLXC/99TDAvd7Tz0scL/31AN+T5vOPOD39NwDfk/PPeD39NwDfk/PPeD39NwDfE+r0OFBbOTB4Xv6ggf4nr7gAb6nL3iA7+kLHuB7WlleHnzoAb6nL3iA7+kLHuB7+oIH+J6+4AG/p6ceGn5Pzz3g9/TcA35Pzz3g9/Sbhzo8935kT6lf9PBa19A29LBAT089LNDTUw8L9PTUwwI9PfWwQE/PPPQFenrqYYGennrA72mqMw/4PT33gN/Tcw/4PT33gN/Tcw/4PT33gN/Tcw/4PT3zwPj7kV3wgN/Tcw/39INZOTxY14kHZv/+4+wvw38oHPzt17ujQweK7sC/PwRrdejAlnfgyztoyzvoqzu4ae+rJx3Q8g54eQeyvAP4Tp46WKiTuwwdwHdy/36tFx86gO/kqQP4Tp46gO/kmQOG7+SpA/hOnjqA7+SpA/hOnjqA7+SpA/hOnjpYvpN5+U7m5TuZl+9kWb6TZflOluU7WZbv5Jv2snrSwfKdLMt3sizfybJ8J8vynVyX7+S6fCfX5Tu5Lt/JN+1b9aSD5Tu5Lt/JdflOrst3cl2+k3X5TtblO1mX72RdvpNv2qPqSQfLd7Iu38m6fCfr8p2sy3eyLd/Jtnwn2/KdbMt38k37UT3pYPlOtuU72ZbvZFu+k235TvblO9mX72RfvpN9+U6+ae+pJx0s38m+fCf78p3sy3eyL9/JbflObst3clu+k9vynXzTPlNPOli+k9vyndyW7+S2fCe35Tu5L9/JfflO7st3cl++k2/aU+pJB8t3cl++k/vyndyX7+S+eidLWb2TpazeyVJW72Qpq3eylNU7WfD38Zo6WL2TBX8fr6mD1TtZ8PfxmjnA38dr6mD5Tsbfx2vqYPlOxt/Ha+pg+U5efh8vWX4fL8Hfx8tl4gC+k83+2gH+Pl5TB/CdPHWA3sku37siei1DB+idPHeA3slzB+idPHeA3slzB+id7HxkUaWhA/ROnjtA7+SpA/h9vOYO0Dt57gC+k6cO4Dt56gC+k6cO4Dt56gC+k18OdNjJ8Pt4OX//oL1bHTqA72TyiQP4Tp45gN/Ha+4AvpOnDuA7eeoAvpOnDuA7eergiT4o9J3xUri+OzhkNUxZHVLWI1s4XZBFmLKeCM7S+JDV+a8PWv4a/3+8mEVl6EE28FDhPbgeHloZetANPNgGHhzeQ//+01yJhx7aBh76+h4e2Xzpbg+0gQf8np57wO/puQf8np57wO/puQf8np572KCnbYOetg162tfq6T70sFZPjz2s1dNjD2v19NjDWj099rBWT489PNLT+lr26pNFYdLvi4T0tn78tSj8zy9t/v3W9PJSzDL6q9SOP8ss7y8+3hn//c6cvDPt9ztz8s703+/M+J15ZPOrNd4Z+v3OnLwz/PudOXln5Pc7c/LO1N/vzMk7o7/fmZN35vc58Nk78/sc+Oyd+X0OfPbO/D4HPnln+u9z4LN35vc58Nk78/sc+Oyd+X0OfPbO1N/vzMk7s+w58OFg2XPVwwH6OSUX+l40Lzx0gH7uN3eAfo42c1AL+rnU3AH6Oc/cAfq5Cctx+Uto6AD9HGLuAL3r5w7QO3nuAD1NTeX4yzpyQOhpOneAfiTPHm6qhH4kezsedu02dIB+JM8doJ9dzx2gn13PHaCfXc8doPfB1AGj98HcAfrZ9dwB+tn13AF8J08dLN/JvE4ntzI8s2P8Tv7eWqxxGTrA7+SZA/hOdps4QO/kJsdxUIdHsqB38twBeifPHaB38twBeifPHaB38twBeifPHaB38twBeifPHaB38tzBQp08XnWs+J18nNn58Lyo4nfyzAF+J88c4HfyzAF+J88c4HfyzAF+J88c4HfyzAF8Jx9brp45gO/kmQOF7+Spgyc6mcrxx4n7XzsQkWNXR6n1/cWHB97Ag2zgoW7gQTfwYBt48A08NHAPzHTcbsSkQw99fQ+P7Fv3ax6OWWKuPPSA3tNXPKD39BUP6D3NrHx48GEuPbJv3d0e0Hv6igf0nr7iAb2nr3jA7+m5B/yennpw/J6ee8Dv6bkH/J6ee9igpx/Zt+5uDxv0tC/V042GHpbq6RMPS/X0iYelenrsoS3V0ycelurpEw9L9fSJh6V6+sTDUj194mGpnj7xsEFPtw16um3Q022Dnu4b9HTfoKf7Bj3dN+jpR/YqutvDBj3dN+jpvkFP9w16uq/f01rW72kt6/e0lvV7Wsv6Pa1l/Z7Wsv66t5b1r09rWf/6tJb1r09rWf/6tNL616eV1r8+rbT+9Wml9a9P6yO7iN3tYYOepg16mjboadqgp2mDnuYNepo36GneoKd5g55+ZGexuz1s0NO8QU/zBj3NG/Q0b9DTskFPywY9LRv0tGzQ04/sNna3hw16Wjboadmgp2WDnpYNerpu0NN1g56uG/R03aCnH9mB7G4PG/R03aCn6wY9XTfo6Uf2IiOlw4PaSNYjG4xdkEWYshhTlmDKqpiyFFOWYcpyTFkNU9YzKf9qKudJU0n9fjGLysjDM7tZ/ZIH18NDK0MPtIEH3sCDwHvox+5ulXjooW7gQTfwYBt48A08tA084Pf01IPj9/TcA35Pzz3g9/TcwwY9/cxuVjd72KCnfa2e7kMPa/X02MNaPT32sFZPDz20tXp67GGtnh57eLynfSjrkeqt8pLV/vqtnW9Er89sUHWzB93Ag23gwTfw0Dbw0Nf38MwGVb/g4cKF42c2qLrZA2/gAb2nr3hA7+krHtB7+ooH9J6+4gG9p694QO/pKx7Qe3ruwcr6PW1l/Z62sn5PW1mqp4ebO1lZqqdPPCzV0ycelurpEw9L9fSJh6V6+sTDUj099kBL9fSJh6V6+sTDUj194mGDnn5mg6qbPWzQ07RBT9MGPU0b9DRt0NO8QU/zBj3NG/Q0b9DTz2xQdbOHDXqaN+hp3qCneYOe5g16Wjboadmgp2WDdW9Z//q0PbNB1c0e1r8+bbL+9WmT9a9Pm6x/fdpkg+vTdYPr03WD69N1g56uG/T0MxtU3exhg56uG/R03aCn6wY9XTfoad2gp3WDntYNelo36OlnduC62cMGPa0b9LRu0NO6QU/rBj1tG/S0bdDTtkFP2wY9/cwWYzd72KCnbYOetg162jboadugp32DnvYNeto36GnfoKef2WLsZg8b9PQjW1sV/d7tVkqXv/bwtXp0/OW3v8svBx3dgdfvv9zqyMEj21rd64CWd8DLO5DlHdTlHejyDmx5B768A/hOnjpYqJPfXvrmoMN3cv/essuLDx3Ad/LUAXwnTx3Ad/LUAXwnTx3Ad/LUAXwnTx3Ad/LUAXwnTx3Ad/LEgZfVO9nL6p3sZfVO9rJ6J3tZvZO9rN7JXlbvZC+rd7KX1TvZy/KdTMt3Mi3fybR8J9PynfzI/lX3Oli+k2n5TqblO5mW72RavpN5+U7m5TuZl+9kXr6TH9mr6l4Hy3cyL9/JvHwn8/KdzMt3sizfybJ8J8vynSzLd/Ij+1Ld62D5TpblO1mW72RZvpNl+U6uy3dyXb6T6/KdXJfv5Ef2oLrXwfKdXJfv5Lp8J9flO7ku38m6fCfr8p2sy3eyLt/Jj+w3da+D5TtZl+9kXb6TdflO1uU72ZbvZFu+k235TrblO/mRvaXudbB8J9vynWzLd7It38m2fCf78p3sy3eyL9/JvnwnP7KP1L0Olu9kX76TfflOxt/Ha+pg+U7G38dr6mD5Tsbfx2vqYPlOxt/Ha+pg+U7G38dr6mD5Tsbfx2vqYPlOXn4fL19+Hy/H38fLZeIAvpPNJg7gO3nqAL6Tpw7QO9nle1dEr2XoAL2T5w7QO3nuAL2TZw4a/D5ecwfonex8ZFGloQP0Tp47QO/kuQP0Tp47QO/kuQP4Tp46gO/kqQP4Tp46gO/kmQP4fbzeHOiwk+H38XL+fq1bHTqA72TyiQP4Tp46gO/kqQP4Tp46gO/kqQP4Tp46gO/kmYObdv9Re/v9KfvTyw8mTWO651NR769PhfuQqWcx3bQzyhUmSmPiNKabZu9Yw/9iKjxksjQmT2NqaUw3fUMo9cVE/NcvZ6nff5xF/5Sn37Lu2gLhbln0hCzXQ1YrQ1mMKUswZdUnZPXvEw6uby9+l6WYsgxTlmPKapiyOqQsLZiyCFMWY8oSTFmYKa+YKa+YKa+Pp3wfyno85ceyHk/5oSx7POXHsh5P+bGsx1N+LOumlCd9Wzlo/2fwjfSup5kvMGkak6UxeRpTS2P6G3JtzOR/+5pf6OBzwpTFmLIEU1bFlKWYsgxTlufLota+g+vrn2NZ7QFZnehbVicbyuqQslrBlEVPyDpuX6Fe21AWY8oSTFkVU5ZiyjJMWY4pq2HK6pCyesGUhZnyHTPlO2bKd8yU75gp359OedWhrKdT/kTW0yl/IuvplB/K6uXplD+R9XTKn8h6OuXtT5d5Bi/W779M/noeQN4cPF0IJ2/s04VwIuvpQjiRBVkIvUAWQi+QhdALZiEQZiEQZiHQ04VwIgsz5Qkz5Qkz5Qkz5Qkz5Qkz5Qkz5Rkz5Rkz5Rkz5Rkz5Rkz5Rkz5Rkz5Rkz5Rkz5Rkz5QUz5QUz5QVyCb8L5BJ+l6dT/kQW5BJ+F8gLtV0gL9R2gbxQ2wXyQm2vkBdqe4W8UNsrZspXzJSvmClfMVO+YqZ8xUz5ipnyFTPlFTPlFTPlFTPlFTPlFTPlFTPlFTPlFTPlFTPlFTPlDTPlDTPlDTPlDTPlDTPlDTPlDTPlDTPlDTPlDTPlHTPlHTPlHTPlHTPlHTPlHTPl//7HZA8mT2NqaUxZm4n2VtKYTg5rkReTqA+hJ4eeuL+gzYZQjUNPRrhSOaCVxoI9Dm1xaA9Dz55JuwKlOJQvQHn44Zw9f1WPvTTOoTUO1TjU4lCPQ1sc2oNQKuXkcQ639t0bX//uNMbKB9j6AVY/wNoH2PGn685HLrprH2PbB9gex57cy34NSx9g+QOsfICtH2BP5sq7vLC9jrH2AdY/wLYPsD2OPbl71tvb+9x4/D6f3OJ6DcsfYOUD7Mln1F77+n/928fYFsee3ShG5fiMvv7dxlj+ACsfYOsHWP0Aax9g/QNs+wDb49izu14uYU/mqrT+wpJ8+O3yDyLOIpIsoppFpFlElkXkWUTtBiLm49vN1z91TNSTiM5ufvhFIvGDqPKYiLKIOItIbiFSPoi8jolqFpFmEVkWkWcRtSyinkRkJYuIsog4iygrGSwrGSwrGez2ZGg0JvIsopZF1JOIvGQRURYRZxFJFlHNItIsoqxk8Kxk8Kxk8KxkaFnJ0LKSoWUlQ8tKhpaVDC0rGVpWMrSsZGhZydCykqFnJUPPSoaelQw9Kxl6VjL0rG8TPWudoWetM/SsdYaetM5ApWQRURYRZxFJFlHNItIsIssi8iyilkWUlQyUlQyUlQyUlQyUlQyUlQyUlQyUlQyUlQyUlQyUlQyclQyclQyclQyclQyclQyclQyclQyclQyclQyclQySlQySlQySlQySlQynN/JVehFpeSd6YfUDrH2A9Q+w7QNsj2NPb+Rjf8PqX3+gF26LorO7/u4n4huILtwWRWd3/f0i0fQmIjq76+9+Is0isluI5jFydtff/UQti6gnEWnJIqIsIs4ikiyimkWkWURZyaBZyaBZyaC3J8P40gxZySKiLCLOIpIsoppFpFlElkXkWUQtiygrGTwrGTwrGTwrGTwrGTwrGTwrGTwrGTwrGTwrGTwrGVpWMrSsZGhZydCykqFlJUPLSoaWlQwtKxla1reJlrXO0LPWGXrWOkPPWmfoWesMPWudoWetM/SsdYaetc7Qs5KhJyUDl5JFRFlEnEUkWUQ1i0iziCyLyLOIWhZRVjJQVjJQVjJQVjJQVjJQVjJQVjJQVjJQVjJQVjJQVjJwVjJwVjJwVjJwVjJwVjJwVjJwVjJwVjJwVjJwVjJIVjJIVjLIryfDCysfYOsHWP0Aax9gzw6cxi9skzG2fYDtcezpvXlXsPQB9myu7O0mz1bHWPkAWz/A6gdY+wDrH2DbB9h+BTvcUJRP7+y6gqUPsPwBVj7AfjBX+sFc6QdzpR/MlX4wV9rjWCsfYOkD7Ad5ZR/klX0wV/bBXNkHc2UfzJV9MFf2wVz5B3PlH8yVfzBX/sFc+Qdz5R/MlX8wV/7BXPkHc+UfzFX7YK7aB3PVPpir9sFctQ/mqn0wV+2DuWofzFX7YK7aB3PVP5ir/sFcnVylvbLZO59cePXmrx+naG383erkWuo1rH+AbR9gT36AoL82MPdOPMLKyXXJa9iTHyDo8vqM3p9s+hOWP8CefL69vWkenz/L2Q+XXML6B9j2AbbHsWc/XNL99WMNvZcxlj7A8gdY+QBbP8DqB1i7gj35jM7mynmObR9gzx5SfluDKjLMZzndkeAKlj7A8gdY+QBbP8DqBWyVMfbsGXymOdY/wPY49vSZ9CtY+gDLH2AlhOX/IDZevnr9nuD7b/+wHLDxytUcNnyD6lcpfhfn17998nuWXOj71V//fPtJs/Li4SQeSeKpSTyaxGNJPJ7E05J4eg7PeAHxb+BJygNLygNLygNLygNLygNLygNLygNLygNLygNPygNPygNPygNPygNPygNPygNPygNPygNPygNPyoOWlActKQ9aUh60pDxoSXnQkvKgJeVBS8qDlpQHLSkPelIe9KQ86El50JPyoCflQU/Kg56UBz0pD3pSHvScPPBSkngoiYeTeCSJpybxaBKPJfF4Ek9L4knKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA75nro0OHuMhjyTx3DIHdNyqwkx1yONJPC2Jp+fwSEni+fVeOKAch55MOZEfUKr08VErNYlHk3gsiceTeFoST8/hqSWJh5J4OIknKQ9qUh7UpDyoSXlQk/KgJuVBTcoDTcoDTcoDTcoDTcoDTcoDTcoDTcoDTcoDTcoDTcoDS8oDS8oDS8oDS8oDS8oDS8oDS8oDS8oDS8oDS8oDT8oDT8oDT8oDT8oDT8oDT8oDT8oDT8oDT8oDT8qDlpQHLSkPWlIetKQ8aEl50JLyoCXlQUvKg5aUBy0pD3pSHvSkPOhJedCT8qAn5UFPyoOelAc9KQ96Uh70nDxopSTx3DPXs6vQrWgSzy1zML2a2krP4aGSxENJPJzE8+u9cEBrHHo25fa6UE7e/tpdNf12V621oTtL4vEknpbE02/gcf6mcR7OHpcUFkph4RQWSWGpKSyawmIpLJ7C0lJYUo59STn2JeXYl5RjX1KOfUk59iXl2JeUY19Sjn1JOfYl5divKcd+TTn2a8qxX1OO/Zpy7NeUY7+mHPs15divKcd+TTn2NeXY15RjX1OOfU059jXl2NeUY19Tjn1NOfY15djXlGPfUo59Szn2LeXYt5Rj31KOfUs59i3l2LeUY99Sjn1LOfY95dj3lGPfU459Tzn2PeXY95Rj31OOfU859j3l2PeUY7+lHPst5dhvKcd+Szn2W8qx31KO/ZZy7Ldbjv1jp3x/fxb4jaWlsPQMll5SWO6Y5Fa+b5poNLxnomsKyx2f/h8b2//j1VR0eEdL7yk8vZQkHkri4SQeSeKpSTyaxGNJPL/eBQe0xaEnRy2XekBZ5K/dSSn/eLGU1/05RAfL2d1UN7NQCgunsEgKS01h0RQWS2HxDBa+Y5IrHT+JUslllDnMSTx3TEDlcsQZSxnyWBKPJ/G0JJ6ewyPllnnr8uKhd57BLatSv4eTRV9/WdtLFCGK4nxRfty0Lq0MRQmiqIooSvNF9e9S4fr2TfBdlCGKckRRDVFUBxRVC6IoQhTFiKIEUVRFFIWY6BUx0StioteHE70PRXVAUVoQRRGiKEYUJYiibkl0ltf3S7ePI0EVUZQhinJEUQ1RVAcUZQVRFCGKYkRRgigKMdENMdENMdHt4UQfniVYQxTVAUV5QRRFiKIYUdTt5+ju76IOnluip74u69TxZR33JJ6WxNNzeFpJ4rnlyJTXvNUbrnA1RhQl+aKmF5NaRRSliKIsX9T0XKs5oqiGKKoDiuoFURQhimJEUYIoqiKKUkRRiIneERO9IyZ6fzjRB1+/aikFURQhimJEUYIoqiKKuiXRq9gh6s/rDIFI+BJliKIcUVRDFNUBRVFBFEWIohhRlCCKqoiiEBOdEBOdEBOdHk704VkCdUBRXBBFEaIoRhQliKJuP0f3wW7nXzyaxGNJPD2HR0oSDyXxcBKPJPEkzZt4Ek9L4kk6fu5/7GV0W8EXDyfxSBJPUl7f87SGleNpa+OxH8/huedJgfdfD/Hy8Sn2PU8K3C2KEUUJoqiKKEoRRRmiKEcU1RBFdUBRhpjohpjohpjohpjo9nCiD5cCTBFFGaIoRxTVEEV1QFH3PClgfrz6//uFv1Ak3POkwN2iGFGUIIqqiKIUUZQhinJEUQ1RVAcU1RATvSEmekNM9PZwog/PElpFFKWIogxRlCOKaoiibj9Hb8Ol/l6SeDiJ5yS1pPDBI6TvPAe0xqEah1oc6nFoi0N7FEpn97NfgVIcynGoxKE1DtU41OJQj0NbHBqfJopPE8WnieLTRPFpovg0UXyaKD5NFJ8mik8TxaeJ49PE8Wni+DRxfJo4Pk0cnyaOTxPHp4nj08TxaZL4NEl8miQ+TRKfJolPk8SnSeLTJPFpkvg0SXyaanyaanyaanyaanyaanyaanyaanyaanyaanyaanyaND5NGp8mjU+TxqdJ49Ok8WnS+DRpfJo0Pk0anyaLT9PZ/RLS6AXtdQjlOFTi0BqHahxqcajHoS0O7WHo2VXgK9D4NHl8mjw+TR6fJo9Pk8enyePT5PFp8vg0tfg0tfg0tfg0tfg0tfg0tfg0tfg0tfg0tfg0tfg09fg09fg09fg09fg09fg09fg09fg09fg09fg09fA0cSlxKMWhHIdKHFrjUI1DLQ71OLTFofFpovg0UXyaKD5NFJ8mik8TxaeJ4tNE8Wmi+DRRfJo4Pk0cnyaOTxPHp4nj08TxaeL4NHF8miT+uUr8c5X45yrxz1Xin6vEP1eJf65nS8v6erzx6999CO1h6NnS8hUoxaEch56MhFZ5QevwHT5bWr4C1TjU4tCTQ13dXtD3R4XfoC0O7WHo2dLyFejJNBm91hGNZAjlOFTi0BqHahxqcajHoS0O7WHo2dLyFWh8miw+TRafJotPk8WnyeLTZPFpsvg0WXyaPD5NHp8mj0+Tx6fJ49Pk8Wny+DR5fJo8Pk0en6YWn6YWn6YWn6YWn6YWn6YWn6YWn6YWn6YWn6YWn6Yen6Yen6Yen6Yen6Yen6Yen6Yen6Yen6Yen6YeniYpJQ6lOPTkw/H6gnodQy0OHb9N1Xv/htZGNoKerJleglIcynGoxKHjg652PtYlaq9/gg4eW6n1+2GNr3++3dJRXjyaxGNJPJ7E05J4eg7PyQry/TyUxMNJPJLEk5QHnJQHnJQHnJQHnJQHnJQHkpQHkpQHkpQHkpQHkpQHkpQHkpQHkpQH9Za5Vv6+5PD1zzrk4SSeW+ZApR88tQ15LInHk3haEk/P4dGzXnjdPf7F4xOe6eP0opTEw0k8ksRTf5nngGocanGox6EtDu1hqJU4lOJQjkMlDo1Pk8WnyeLTZPFpsvg0WXyaPD5NHp8mj0+Tx6fJ49Pk8WnqSWdiPelMrEsST03i0SSee84s7cVjwzOk7kk8LYmnp/DUUpJ4KImHk3gkiacm8dyTB0ovnv7OMzqtrt93MfLXifrgtLoWQxTl+aJcD1GtDEU1RFEdUBSVfFGzTSQrEaIoRhQliKIqoihFFGWIohxRVEMU1QFFMWKiM2KiM2Ki88OJ3oeiKqIoRRRliKIcUVRDFHV7og9/K7Hec2eD9uMKsBUZ8lASDyfxSBJPTeK5J8Mav3jqx1/p77kN4tdETb+o3nPPxN2iGqKoni9qelpTC6IoQhTFiKIEUVRFFKWIogxRlCOKaoiiEBNdERNdERNdH0704TcdFURRFVGUIooyRFGOKOr2RKfhVzm9PaTZRjxWknjuXrI19iHPPek4u2m4miTx1CQeTeKxJB5P4mlJPDk3w1cvSTyUxJOUB56UB56UB56UB56UB56UB56UB56UBy0pD1pSHrSkPGhJedCS8qAl5UFLyoOWlActKQ9aUh70pDzoSXnQk/KgJ+VBT8qDnpQHPSkPelIe9KQ86Dl5oKc7Lvn3Ssof/6Z3ngNqcWh4xyWN77ik8R2XNL7jksZ3XNKz/eIbvX7wuokPoR6Htji0h6Fn+8VfgVIcynGoxKE1DtU4ND5NHJ8mjk8TX5mmWkZQKXEoxaEch0ocWuPQs2l621e82TCbznapvwL1OLTFoT0MPdvg/gqU4lCOQyUOrXFofJpqfJpqfJrqpWnqQ2gPQ7XEoRSHchwqceiVbDqBahxqcajHoS0OvdJ0bRjhVuJQikM5DpU4tMahGoeeTFMvfkD7+AzmbIP7K9AWh/Yw9GyD+15eP77Rqw6hFIeeTFN//eRHLcOfctGzDe778VD3H4/XDz/Xsw3ur0A1DrU41OPQFof2MPRsg/srUIpDOQ49+a5euL2gOjyXOFvIvwLVONTiUI9DWxzaw9CzpesrUIpDOQ6NT1OPT1OPT1O/NE3DHO4eh7Y4tEehVkocSnEox6ESh9Y4VONQi0M9Dm1xaHyaKD5NFJ8mik8TxaeJ4tNE8Wmi+DRRfJooPk0UnyaOTxPHp4nj08TxaeL4NHG46YwtDvU4tMWh4fMmkxKHUhzKcajEoTUOjU+TxKdJ4tMk8WmS+DTV+DTV+DTV+DTV+DTV+DTV+DTV+DTV+DTV+DTV+DRpfJo0Pk0anyaNT5PGp0nj06TxadL4NGl8mjQ+TRafJotP09kjK+XtBg8iGkIlDq1xqMahFod6HHoyTVTLC+o8hPYw9OxRiitQikM5DpU4tMahGodaHOpxaHyaPD5NLT5N7dI06RDKcajEoTUO1TjU4lCPQ69MU/MhtIehvcShFIeeTVN/3ZTKNPyufrYWfgVa41CNQy0O9Ti0xaE9CvWztfArUIpDOQ6VOLTGoVemiXkItTjU49AWh/YwlEocejZN0qfQs2mS1wk8SxlCJQ49mSbWN8HDe+D9bC38CvRkmvjYDeyPPQVlCPU4tJ0Jbm9QG0J7GHq2Fn4FSnEox6ESh9Y4VONQi0NPpkn4NcNiwxk+Wwu/Au1h6Nla+BUoxaEch0ocWuNQjUMtDo1Pk8SnSeLTVC9NUx1CKQ7lOFTi0BqHahx6JZtOoB6Htji0h6Fa4tArTdeHEa4ch0ocWuPQk2mqrzt5/9g2cwi1ONSvQHUIbXFoD0PP1sKvQCkO5ThU4tAah2ocanFofJosPk0WnyaPT5PHp8nj0+TxafL4NHl8mjw+TR6fJo9Pk8enqcWnqcWnqcWnqcWnqcWnqcWnqcWbrnkc2uLQHob2EodSHMpxqMShNQ6Nnzf1+DT1+DT1+DT18DS1UuJQikM5DpU4tMahGodaHOpxaItD49NE8Wmi+DRRfJooPk0UnyaKTxPFp4ni00TxaaL4NHF8mjg+TRyfJo5PE8eniePTxPFp4vg0cXyaztbClV4X23S4u1A7Wwu/AqU4lONQiUNrHKpxqMWhHoe2C1AuQ2gPQ2uJQykOPZ2m8gbVIVTi0HoBKmPBGoeefa72unSrPob2MPRsVfoKlOJQjkMlDq1xqMahFof6FWgdQlsc2sNQK3HopWlqQyjHoRKH1jhU49DTaXqdS2iTIdTj0JNpsvK6xGc8hvYr0KHXs1XpK9CTz9XevJoN0/9sffgK9ORz9fJKfy80hHoc2uLQHoaeLfJegVIcynHo2Uadb5/r11r7EFrjUI1DTw71rwvuL6iNvXoc2uLQHoaeLfJegVIcynGoxKE1DtU4ND5NPT5NPT5NPTxNvZQ4lOJQjkMlDq1xqMahFod6HNri0Pg0UXyaKD5NFJ8mik8TxaeJ4tNE8Wmi+DRRfJooPk0cnyaOTxPHp4nj08TxaeL4NJ0t8n4tzR/Qr8XGIdTj0BaHhrfL71LiUIpDOQ6VOLTGoRqHWhzqcWiLQ+PTVOPTVOPTVOPTVOPTVOPTVOPTVOPTVOPTVOPTVOPTpPFp0vg0aXyaND5NGp8mjU+TxqdJ49Ok8WnS+DRZfJosPk0WnyaLj4TFR8LiI2HxkbD4SJxt00yvtXChP6+F//MvIbXjAdI//RJGebFoCku7gYWKfP9aM/1pS5o3np7Dc7bB8+08lMTDSTy3TJt/PyvztZ41ZLEUFk9haSksPYOllxQWSmHhFBZJYakpLCnHfk859nvKsd/vPvZlyNL/fhYtpaSwUAoLp7BICssdx/7rp076+41jbyyawmIpLJ7C0lJYegYLlRQWSmHhFBZJYUk59inl2KeUY5/uPvbbkKWlsPQMFi4pLJTCwiksN/f+CUtNYdEUFkth8RSWm8/5xYYsPYNFSgoLpbBwCouksNQUllt6376XFPv7loBvLJbC4iks96ySl9cqLA2/80nP4am3dH/XF00d0lAODefQSA5NzaHRHBrLofEcmpZD01NoNOVa2RcPJfFwEo8k8dQkHk3isSQeT+JpSTw9h8eS8sCS8sCS8sDuz4M+5KlJPJrEY0k8nsTTknh6Do+XJB5K4uEknqQ88KQ88KQ88KQ88KQ88KQ88KQ8aEl50JLyoCXlQUvKg5aUBy0pD1pSHrSkPGhJedCS8qAn5UFPyoOelAc9KQ96Uh70pDzoSXnQk9YPetL6Qc9ZP6BSkngoiYeTeCSJpybxaBKPJfF4Ek9L4knKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA0rKA07KA07KA07KA07KA07KA07KA07KA07KA07KA07KA0nKA0nKA0nKA0nKA0nKA0nKA0nKA0nKA0nKg9Pb+MhfPJX+mofp2FWKvxJzyMNJPJLEU5N4NInHknj8Dp6vZdYXz5/u6B8cBHzsk/F1dvJ2EPDw/urjbuHyuq/uj62k//nvUrPj775tNv31z8Ns+0lm+w8ye3p75ZZm6SeZ5Z9kVn6S2fqTzOpPMms/yexPOoPSn3QGpT/pDMp+0hmU/aQzKPtJZ1D2k86g7CedQdlPOoMypDOoQxTSmc4h6oEzknas4vL7D6K9ieqAorwgiiJEUYwoKr/Z5Pglva/remUoqiKKUkRRBiiq5UdC1e8Xf/2zDkURoqj8Qdfj97+/Vo/aUFT+oKsfM6VtLMoQReWfulg59oQwGSZ6yz91sfoSpToU1QFF9YIoihBF5Z+6mB1Hn/nw6OuCKKo+IKodotqwZroiirrnXgR93Ytg9V3UweNJPC2Jp6fwcClJPJTEw0k8ksRTk3juuTep8oun/3V4MLUjaZjGogxRlCOKaoiiOqAoKoiiCFEUp4v6+nReol7nqF/fYA9Rgiiq5osSP0RVHopSRFGGKCo/0VmPF7PXoaiGKKoDiuKCKIoQRTGiKEEUVRFFKaIoQxSFmOiMmOiMmOjybKI3GooiRFGMKEoQRVVEUYooyhBFOaKohiiqA4qqiIleERO9IiZ6RUz0ipjoFTHRK2KiV8REr4iJXhETXRETXRETXRETXRETXRETXRETXRETXRETXRETXRFXXQxxHd0Q19ENcR3dENfRrSKKQlxHN8R1dENcRzfEdXRDTHRHTHRHTHRHTHRHTHRHTHRHTHRHTHRHTHRHTHRHTPSGmOgNMdEbYqI3xERviIneEBO9ISZ6Q0z0hpjoDTHRO2Kid8RE74iJ3hETvSMmekdM9I6Y6B0x0e958JHL61mKMvpRN77nwccpj9zz4OMFHkri4SSeewLv9OmjX3rxIaoiitJ0UdNHleSmRyp/SdTsARy56ZHKm0U1RFE9X9SsGuSmRypvFkWIohhRlCCKqoiiFFGUIYpyRFENURRiojNiojNiovOziT68vUhYEEVVRFGKKMoQRTmiqIYoqgOKkoIoihBFISa6ICa6ICa6ICa6ICa6ICa6ICa6ICZ6RUz0ipjoFTHRK2KiV8REr4iJXhETvSImekVM9IqY6IqY6Iq46qKI6+iKuI6uFVEU4jq6Iq6jK+I6uiKuoyviOrohrqMbYqIbYqIbYqIbYqIbYqIbYqIbYqIbYqIbYqI7YqI7YqI7YqI7YqI7YqI7YqI7YqI7YqI7YqI7YqI3xERviIneEBO9ISZ6Q0z0hpjoDTHRG2KiN8REb4iJ3hETvSMmekdM9I6Y6B0x0fvfnOgHjyXxeBJPS+GpBfDXqGvJ/5XX6i9Rwx+or0UQRVVEUYooyhBFOaKohiiqA4qigiiKEEU9m+i9DEU9kOi9fovSMuw+qoiiFFGUIYpyRFENUVQHFMUFURQhimJEUYiJzoiJzoiJzoiJzoiJzoiJzoiJLoiJLoiJLoiJLoiJLoiJLoiJLoiJLoiJLoiJLoiJXhETvSImekVM9IqY6BUx0StiolfERK+IiV4RE70iJroiJroiJvo9TxXeLQox0RUx0RUx0RUx0RUx0RUx0RUx0Q0x0Q0x0Q0x0Q0x0e2BRHeeiVJEUYYoyhFFNURRHVCUF0RRhCjqgUQ3nYkSRFEVUZQiijJEUY4oKj/RVegQJTYU1QFFtYIoihBFMaKo/ERXlpcoH4qqiKIUUZQhinJEUQ1RVAcU1QuiKEIUxY+KqsNTl/5Eor++zWgbiqqIohRRlCGKckRRDVFUxxOlpSCKeiDRqc5EMaIoQRRVEUUpoihDFOWIohqiqA4o6oFnRi+IOsmponqIKt4nooj6S5S/izp4ahKPJvFYEo8n8bQknn4Hzy8dBCzfooj1Twtq//zidlzj6W+LzCyjv0vNjr/L8v7ib7NnzxTuaZZ+kln+SWblJ5mtP8ms/iSz9pPM+k8y236S2Z90BiU/6QxKftIZlPykMyj5SWdQ8pPOoOQnnUHJTzqDkp90BiVIZ1CHKKQznW9R9YEzknZcl+PhJntaCVEUI4oSRFEVUVR+s0k5jj6hMhRliKIcUVQDFKX5kTDdc1pVEEXlD/r8YqHmD7r6MVPaxqIaoqj8UxcrxwMSJsNEt/xTF6svUapDUYQoihFFCaKomi/KjqPPfHj0mSKKsgdEtUNUG9aMOaKoe+5F0Ne9CFbfRR08PYfHSxIPJfFwEo8k8dQkHk3isSSee+5Nqvzi6X8dHvOftVFviKI6oKhWEEURoihGFCWIomq6KKbyEvU6R339Epk2RRRl+aLED1GVh6IcUVRDFJWf6NOf3NNeEEURoihGFCWIoiqiKEUUZYiiHFFUQxQFmOhWABPdCmCiW3k20RsNRQmiqIooShFFGaIoRxTVEEV1QFFUEEURoijERCfERCfERCfERCfERCfERCfERCfERGfERGfERGfERGfERGfERGfERGfERGfERGfERGfERBfERBfEVRcBXEc3AVxHN6mIogDX0U0A19FNANfRTQDX0U0Q19Er4jp6RUz0ipjoFTHRK2KiV8REr4iJXhETvSImekVMdEVMdEVMdEVMdEVMdEVMdEVMdEVMdEVMdEVMdEVMdENMdENMdENMdENMdENMdENMdENMdENMdENMdENM9HsefOTyepai/EnUwUNJPJzEI0k8NYnnnsA7ffrol158iDJEUZ4uavqokt30SOUviZo9gGM3PVJ5r6ibHqm8WRTli5pWw02PVN4sShBFVURRiijKEEU5oqiGKKoDiuoFURRionfERO+Iid6fTfTx7UVdEUUZoihHFNUQRXU8UV4KoihCFMWIogRRFGCiewFMdC+Aie4FMNG9ACa6F8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REZ8REZ8REZ8REZ8BVF+eKKApwHd0ZcB3dGXAd3RlwHd0ZcB3dBXAd3QVwHd0FcB3dBTHRBTHRBTHRBTHRBTHRBTHRBTHRK2KiV8REr4iJXhETvSImekVM9IqY6BUx0StiolfERFfERFfERFfERFfERFfERFfERFfERFfERFfERFfERDfERDfERDfERDfERDfERDfERDfERLe/OdEPnpbE03N4vCTxAP4atd/zoOCvifKXqOEP1LsroihDFOWIohqiqA4oqhVEUYQoihFFCaKoZxO9l6GoBxK9129RWobd1wxRlCOKaoiiOqCoXhBFEaIoRhQliKIqoijERO+Iid4RE70jJnoHTPRWABO9FcBEbwUw0VsBTPRWABO9FcBEbwUw0VsBTPRWABO9FcREJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REJ8REZ8REZ8REZ8REZ8REZ8REZ8REZ8REZ8REZ8REZ8REF8REF8REF8REF8REF8REF8RElyfudeGZKEcU1RBFdUBRtSCKIkRRjChKEEU9kOimM1GKKMoQRTmiqIYoqgOK0vxEV6FDlNhQFCGKYkRRgiiqIorKT3RleYnyoShDFOWIohqiqA4oygqiKEIUxYiiBFFUfVRUHZ662BOJ/vo2o20oyhBFOaKohiiqA4rygiiKEEUxoqgHEp3qTFRFFKWIogxRlCOKaoiiOqCoB54ZvSCKEEUxkqiv//hf//Lf//Vf/uN/+c//4wvyx//7n//2n/79X//rv/3jP//9f/+3//d/vl77fwE=","file_map":{"11":{"source":"// docs:start:default-trait\ntrait Default {\n    fn default() -> Self;\n}\n// docs:end:default-trait\n\nimpl Default for Field { fn default() -> Field { 0 } }\n\nimpl Default for u8 { fn default() -> u8 { 0 } }\nimpl Default for u32 { fn default() -> u32 { 0 } }\nimpl Default for u64 { fn default() -> u64 { 0 } }\n\nimpl Default for i8 { fn default() -> i8 { 0 } }\nimpl Default for i32 { fn default() -> i32 { 0 } }\nimpl Default for i64 { fn default() -> i64 { 0 } }\n\nimpl Default for () { fn default() -> () { () } }\nimpl Default for bool { fn default() -> bool { false } }\n\nimpl<T, let N: u32> Default for [T; N] where T: Default {\n    fn default() -> [T; N] {\n        [T::default(); N]\n    }\n}\n\nimpl<T> Default for [T] {\n    fn default() -> [T] {\n        &[]\n    }\n}\n\nimpl<A, B> Default for (A, B) where A: Default, B: Default {\n    fn default() -> (A, B) {\n        (A::default(), B::default())\n    }\n}\n\nimpl<A, B, C> Default for (A, B, C) where A: Default, B: Default, C: Default {\n    fn default() -> (A, B, C) {\n        (A::default(), B::default(), C::default())\n    }\n}\n\nimpl<A, B, C, D> Default for (A, B, C, D) where A: Default, B: Default, C: Default, D: Default {\n    fn default() -> (A, B, C, D) {\n        (A::default(), B::default(), C::default(), D::default())\n    }\n}\n\nimpl<A, B, C, D, E> Default for (A, B, C, D, E) where A: Default, B: Default, C: Default, D: Default, E: Default {\n    fn default() -> (A, B, C, D, E) {\n        (A::default(), B::default(), C::default(), D::default(), E::default())\n    }\n}\n","path":"std/default.nr"},"23":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"38":{"source":"// docs:start:add-trait\ntrait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field { fn add(self, other: Field) -> Field { self + other } }\n\nimpl Add for u64 { fn add(self, other: u64) -> u64 { self + other } }\nimpl Add for u32 { fn add(self, other: u32) -> u32 { self + other } }\nimpl Add for u16 { fn add(self, other: u16) -> u16 { self + other } }\nimpl Add for u8 { fn add(self, other: u8) -> u8 { self + other } }\n\nimpl Add for i8 { fn add(self, other: i8) -> i8 { self + other } }\nimpl Add for i16 { fn add(self, other: i16) -> i16 { self + other } }\nimpl Add for i32 { fn add(self, other: i32) -> i32 { self + other } }\nimpl Add for i64 { fn add(self, other: i64) -> i64 { self + other } }\n\n// docs:start:sub-trait\ntrait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field { fn sub(self, other: Field) -> Field { self - other } }\n\nimpl Sub for u64 { fn sub(self, other: u64) -> u64 { self - other } }\nimpl Sub for u32 { fn sub(self, other: u32) -> u32 { self - other } }\nimpl Sub for u16 { fn sub(self, other: u16) -> u16 { self - other } }\nimpl Sub for u8 { fn sub(self, other: u8) -> u8 { self - other } }\n\nimpl Sub for i8 { fn sub(self, other: i8) -> i8 { self - other } }\nimpl Sub for i16 { fn sub(self, other: i16) -> i16 { self - other } }\nimpl Sub for i32 { fn sub(self, other: i32) -> i32 { self - other } }\nimpl Sub for i64 { fn sub(self, other: i64) -> i64 { self - other } }\n\n// docs:start:mul-trait\ntrait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field { fn mul(self, other: Field) -> Field { self * other } }\n\nimpl Mul for u64 { fn mul(self, other: u64) -> u64 { self * other } }\nimpl Mul for u32 { fn mul(self, other: u32) -> u32 { self * other } }\nimpl Mul for u16 { fn mul(self, other: u16) -> u16 { self * other } }\nimpl Mul for u8 { fn mul(self, other: u8) -> u8 { self * other } }\n\nimpl Mul for i8 { fn mul(self, other: i8) -> i8 { self * other } }\nimpl Mul for i16 { fn mul(self, other: i16) -> i16 { self * other } }\nimpl Mul for i32 { fn mul(self, other: i32) -> i32 { self * other } }\nimpl Mul for i64 { fn mul(self, other: i64) -> i64 { self * other } }\n\n// docs:start:div-trait\ntrait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field { fn div(self, other: Field) -> Field { self / other } }\n\nimpl Div for u64 { fn div(self, other: u64) -> u64 { self / other } }\nimpl Div for u32 { fn div(self, other: u32) -> u32 { self / other } }\nimpl Div for u16 { fn div(self, other: u16) -> u16 { self / other } }\nimpl Div for u8 { fn div(self, other: u8) -> u8 { self / other } }\n\nimpl Div for i8 { fn div(self, other: i8) -> i8 { self / other } }\nimpl Div for i16 { fn div(self, other: i16) -> i16 { self / other } }\nimpl Div for i32 { fn div(self, other: i32) -> i32 { self / other } }\nimpl Div for i64 { fn div(self, other: i64) -> i64 { self / other } }\n\n// docs:start:rem-trait\ntrait Rem{\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u64 { fn rem(self, other: u64) -> u64 { self % other } }\nimpl Rem for u32 { fn rem(self, other: u32) -> u32 { self % other } }\nimpl Rem for u16 { fn rem(self, other: u16) -> u16 { self % other } }\nimpl Rem for u8 { fn rem(self, other: u8) -> u8 { self % other } }\n\nimpl Rem for i8 { fn rem(self, other: i8) -> i8 { self % other } }\nimpl Rem for i16 { fn rem(self, other: i16) -> i16 { self % other } }\nimpl Rem for i32 { fn rem(self, other: i32) -> i32 { self % other } }\nimpl Rem for i64 { fn rem(self, other: i64) -> i64 { self % other } }\n\n// docs:start:neg-trait\ntrait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field { fn neg(self) -> Field { -self } }\n\nimpl Neg for i8 { fn neg(self) -> i8 { -self } }\nimpl Neg for i16 { fn neg(self) -> i16 { -self } }\nimpl Neg for i32 { fn neg(self) -> i32 { -self } }\nimpl Neg for i64 { fn neg(self) -> i64 { -self } }\n// docs:end:neg-trait-impls\n\n","path":"std/ops/arith.nr"},"53":{"source":"use dep::bignum::BigNum;\nuse dep::bignum::fields::U256::{U256Params, U256_Instance};\nuse dep::bignum::runtime_bignum::{BigNumParamsTrait as RuntimeBigNumParamsTrait, BigNumInstance};\n\nuse lib::mult::{\n    benchmark_mult_U256, benchmark_mult_U384, benchmark_mult_U1024, benchmark_mult_U2048,\n    benchmark_mult_U4096\n};\nuse lib::add::{benchmark_add_U256, benchmark_add_U384, benchmark_add_U1024, benchmark_add_U2048, benchmark_add_U4096};\nuse lib::sub::{benchmark_sub_U256, benchmark_sub_U384, benchmark_sub_U1024, benchmark_sub_U2048, benchmark_sub_U4096};\nuse lib::udiv::{\n    benchmark_udiv_U256, benchmark_udiv_U384, benchmark_udiv_U1024, benchmark_udiv_U2048,\n    benchmark_udiv_U4096\n};\nuse lib::umod::{\n    benchmark_umod_U256, benchmark_umod_U384, benchmark_umod_U1024, benchmark_umod_U2048,\n    benchmark_umod_U4096\n};\nuse lib::eq::{benchmark_eq_U256, benchmark_eq_U384, benchmark_eq_U1024, benchmark_eq_U2048, benchmark_eq_U4096};\n\nfn main(a: Field, b: Field) {\n    benchmark_add_U4096(a, b);\n}\n","path":"/home/hdvanegasm/Documents/hashcloak/aztec/noir-bigint-bench/benchmarking/src/main.nr"},"55":{"source":"mod utils;\nmod bignum_test;\nmod fields;\nmod runtime_bignum;\nmod runtime_bignum_test;\n\nuse dep::std;\nuse crate::utils::u60_representation::U60Repr;\nuse crate::utils::arrayX::ArrayX;\nuse crate::utils::split_bits;\nuse crate::runtime_bignum::BigNumInstance as RuntimeBigNumInstance;\nuse crate::runtime_bignum::BigNumInstanceTrait as RuntimeBigNumInstanceTrait;\nuse crate::runtime_bignum::BigNumParamsTrait as RuntimeBigNumParamsTrait;\nuse crate::runtime_bignum::BigNumTrait as RuntimeBigNumTrait;\nstruct BigNum<let N: u32, Params> {\n    limbs: [Field; N]\n}\n\n/**\n * @brief BigNumParamsTrait defines a \"field\" with which to parametrise BigNum.\n * @description The \"field\" does not need to be prime, any value *should* work (TODO: test!)\n**/\n// \n// trait BigNumParamsTrait<let N: u32, Params> where Params: RuntimeBigNumParamsTrait<N>, RuntimeBigNumInstance<N, Params>: RuntimeBigNumInstanceTrait<BigNum<N, Params>> {\ntrait BigNumParamsTrait<let N: u32> where Self: RuntimeBigNumParamsTrait<N> {\n\n    fn get_instance() -> RuntimeBigNumInstance<N, Self> where Self: RuntimeBigNumParamsTrait<N>;// <N, Params>;\n\n    /**\n     * @brief modulus_bits = log2(modulus) rounded up\n     **/\n    fn modulus_bits() -> u32;\n\n    fn has_multiplicative_inverse() -> bool { true }\n}\n\ntrait BigNumTrait where BigNumTrait: std::ops::Add + std::ops::Sub + std::ops::Mul + std::ops::Div + std::ops::Eq + RuntimeBigNumTrait {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    fn from(limbs: [Field]) -> Self { RuntimeBigNumTrait::from(limbs) }\n    fn new() -> Self { RuntimeBigNumTrait::new() }\n    fn one() -> Self { RuntimeBigNumTrait::one() }\n    fn modulus() -> Self;\n    fn modulus_bits(self) -> u32;\n    fn num_limbs(self) -> u32;\n    fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn __pow(self, exponent: Self) -> Self;\n    fn __neg(self) -> Self;\n    fn __add(self, other: Self) -> Self;\n    fn __sub(self, other: Self) -> Self;\n    fn __mul(self, other: Self) -> Self;\n    fn __div(self, other: Self) -> Self;\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn __invmod(self) -> Self;\n    fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    fn __batch_invert_slice(x: [Self]) -> [Self];\n    fn __is_zero(self) -> bool { RuntimeBigNumTrait::__is_zero(self) }\n    fn __eq(self, other: Self) -> bool { RuntimeBigNumTrait::__eq(self, other) }\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(lhs: [[Self; LHS_N]; NUM_PRODUCTS], lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS], rhs: [[Self; RHS_N]; NUM_PRODUCTS], rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS], add: [Self; ADD_N], add_flags: [bool; ADD_N]) -> (Self, Self);\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(lhs: [[Self; LHS_N]; NUM_PRODUCTS], lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS], rhs: [[Self; RHS_N]; NUM_PRODUCTS], rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS], add: [Self; ADD_N], add_flags: [bool; ADD_N]);\n    fn validate_in_range(self){ RuntimeBigNumTrait::validate_in_range(self) }\n    fn validate_in_field(self);\n    fn assert_is_not_equal(self, other: Self);\n    fn neg(self) -> Self;\n    fn add(self, other: Self) -> Self { self + other }\n    fn sub(self, other: Self) -> Self { self - other }\n    fn mul(self, other: Self) -> Self { self * other }\n    fn div(self, other: Self) -> Self { self / other }\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n    fn eq(self, other: Self) -> bool { self == other }\n    fn get(self) -> [Field] { RuntimeBigNumTrait::get(self) }\n    fn get_limb(self, idx: u64) -> Field  { RuntimeBigNumTrait::get_limb(self, idx) }\n    fn set_limb(&mut self, idx: u32, value: Field)  { RuntimeBigNumTrait::set_limb(self, idx, value) }\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self { RuntimeBigNumTrait::conditional_select(lhs, rhs, predicate) }\n    fn to_le_bytes<let X: u32>(self) -> [u8; X] { RuntimeBigNumTrait::to_le_bytes(self) }\n}\n\nimpl<let N: u32, Params> BigNumTrait for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N> {\n\n    \n    // Weird compiler issue where if we do not pass `Self` as a parameter to these methods,\n    // then a generic struct that conforms to BigNumTrait cannot access these methods?\n    // the Params: BigNumParamsTrait<N> needs to be satisfied, but the BigNumTrait has no knowledge of BigNumParamsTrait?\n    // but...passing in a Self parameter seems to fix. really weird\n    fn modulus_bits(_: Self) -> u32 {\n        let r: u32 = Params::modulus_bits();\n        r\n    }\n    fn num_limbs(_: Self) -> u32 { N }\n\n    fn modulus() -> Self {\n        Params::get_instance().modulus()\n    }\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C  O  N  S  T  R  U  C  T  O  R  S\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // fn new() -> Self {\n    //     BigNum { limbs: [0; N] }\n    // }\n\n    // fn one() -> Self {\n    //     let mut result = BigNum::new();\n    //     result.limbs[0] = 1;\n    //     result\n    // }\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### U N C O N S T R A I N E D    F U N C T I O N S\n    // ### NOTE: these functions call unconstrained internal implementations because trait impl modifiers are not supported \n    // ####################################################################################################################\n    // ####################################################################################################################\n    fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        Params::get_instance().__derive_from_seed(seed)\n    }\n\n    fn __neg(self) -> Self {\n        Params::get_instance().__neg(self)\n    }\n\n    fn __add(self, rhs: Self) -> Self {\n        Params::get_instance().__add(self, rhs)\n    }\n\n    fn __sub(self, rhs: Self) -> Self {\n        Params::get_instance().__sub(self, rhs)\n    }\n\n    fn __mul(self, rhs: Self) -> Self {\n        Params::get_instance().__mul(self, rhs)\n    }\n\n    fn __div(self, rhs: Self) -> Self {\n        Params::get_instance().__div(self, rhs)\n    }\n\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        assert(Params::has_multiplicative_inverse());\n        Params::get_instance().__batch_invert(x)\n    }\n\n    // n.b. needs to be declared unconstrained because we return a slice from an unconstrained runtime\n    unconstrained fn __batch_invert_slice(x: [Self]) -> [Self] {\n        assert(Params::has_multiplicative_inverse());\n        Params::get_instance().__batch_invert_slice(x)\n    }\n    fn __invmod(self) -> Self {\n        assert(Params::has_multiplicative_inverse());\n        Params::get_instance().__invmod(self)\n    }\n\n    fn __pow(self, exponent: Self) -> Self {\n        Params::get_instance().__pow(self, exponent)\n    }\n\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (Self, Self) {\n        Params::get_instance().__compute_quadratic_expression(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        )\n    }\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C O N S T R A I N E D    F U N C T I O N S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    /**\n     * @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo Params::modulus()\n     * @description The expression is of the form (when evaluated as an integer relation):\n     *\n     * \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n     *\n     * The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n     *\n     * Note: this method requires the remainder term of the expression to be ZERO\n     * When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n     * This can be achieved by minimizing the number of degree-2 relations required.\n     *\n     * The expensive parts of this algorithm are the following:\n     *      1. evaluating the limb products required to compute `lhs * rhs`\n     *      2. applying range constraints to validate the result is 0\n     *\n     * Range constraints are needed for the following reason:\n     * When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n     * Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n     * Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n     * To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n     * (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n     * To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n     * We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n     * TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n     * I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n     * TODO: explain why we apply a 126-bit range check, this feels like a magic number\n     * (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n     * TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n     * \n     * @param lhs_terms a 2D array of BigNum\n     * @param lhs_flags a 2D array of sign flags\n     * @param rhs_terms a 2D array of BigNum\n     * @param rhs_flags a 2D array of sign flags\n     * @param linear_terms an array of BigNum\n     * @param linear_flags an array of sign flags\n     **/\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) {\n        Params::get_instance().evaluate_quadratic_expression(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        Params::get_instance().validate_in_field(self);\n    }\n\n    /**\n     * @brief Validate self != other\n     * @details If A == B, then A == B mod N.\n     *          We can efficiently evaluate A == B mod N where N = circuit modulus\n     *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n     *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n     *          (todo: compute how tiny)\n     **/\n    fn assert_is_not_equal(self, other: Self) {\n        Params::get_instance().assert_is_not_equal(self, other);\n    }\n\n    fn neg(self) -> Self {\n        Params::get_instance().neg(self)\n    }\n\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        Params::get_instance().__udiv_mod(self, divisor)\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        Params::get_instance().udiv_mod(self, divisor)\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        Params::get_instance().udiv(self, divisor)\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        Params::get_instance().umod(self, divisor)\n    }\n}\n\nimpl<let N: u32, Params> BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n}\n\nimpl<let N: u32, Params> std::ops::Add for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        Params::get_instance().add(self, other)\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Sub for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        Params::get_instance().sub(self, other)\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Mul for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        Params::get_instance().mul(self, other)\n    }\n}\n\nimpl<let N: u32, Params> std::ops::Div for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        Params::get_instance().div(self, other)\n    }\n}\n\nimpl<let N: u32, Params> std::cmp::Eq for BigNum<N, Params> where Params: BigNumParamsTrait<N> + RuntimeBigNumParamsTrait<N>  {\n\n    fn eq(self, other: Self) -> bool {\n        let bn: RuntimeBigNumInstance<N, Params> = Params::get_instance();\n        bn.eq(self, other)\n    }\n}\n","path":"/home/hdvanegasm/nargo/github.com/noir-lang/noir-bignumv0.3.0/src/lib.nr"},"58":{"source":"use dep::std;\nuse crate::utils::split_bits;\n\n/**\n * @brief Array abstraction, whose size is a known multiplier `SizeMultiplier` of an initial size `N`\n *\n * @note ArrayX is a workaround for the lack of arithmetic over generics.\n *       e.g. [Field; N * 2] is not currently possible\n *       This abstraction can be removed once Noir supports arithmetic on generics.\n**/\nstruct ArrayX<T, let N: u32, let SizeMultiplier: u32> {\n    segments: [[T; N]; SizeMultiplier]\n}\n\nimpl<T, let N: u32, let SizeMultiplier: u32> std::convert::From<[T; N]> for ArrayX<T, N, SizeMultiplier> where T: std::default::Default { \n    fn from(input: [T; N]) -> Self {\n        assert(N == 1);\n        let mut result = ArrayX::new();\n        result.segments[0] = input;\n        result\n    }\n}\n\nimpl<T, let N: u32, let SizeMultiplier: u32> std::convert::From<[[T; N]; SizeMultiplier]> for ArrayX<T, N, SizeMultiplier> where T: std::default::Default { \n    fn from(input: [[T; N]; SizeMultiplier]) -> Self {\n        ArrayX{ segments: input }\n    }\n}\n\nimpl<T, let N: u32, let SizeMultiplier: u32> std::cmp::Eq for ArrayX<T, N, SizeMultiplier> where T: std::cmp::Eq { \n    fn eq(self, other: Self) -> bool {\n        let mut result: bool = true;\n        for i in 0..SizeMultiplier {\n            for j in 0..N {\n                result = result & (self.segments[i][j] == other.segments[i][j]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let SizeMultiplier: u32> ArrayX<T, N, SizeMultiplier> {\n\n    fn new() -> Self where T: std::default::Default {\n        ArrayX { segments: [[T::default(); N]; SizeMultiplier] }\n    }\n\n    fn mul_assign(&mut self, i: u32, rhs: T) where T: std::ops::Mul {\n        let segment = i / N;\n        let index = i % N;\n        self.segments[segment][index] *= rhs;\n    }\n\n    fn add_assign(&mut self, i: u32, rhs: T) where T: std::ops::Add {\n        let segment = i / N;\n        let index = i % N;\n        self.segments[segment][index] += rhs;\n    }\n\n    fn sub_assign(&mut self, i: u32, rhs: T) where T: std::ops::Sub {\n        let segment = i / N;\n        let index = i % N;\n        self.segments[segment][index] -= rhs;\n    }\n\n    fn set(&mut self, i: u32, x: T) {\n        let segment = i / N;\n        let index = i % N;\n        self.segments[segment][index] = x;\n    }\n\n    fn get(self, i: u32) -> T {\n        let segment = i / N;\n        let index = i % N;\n        self.segments[segment][index]\n    }\n\n    unconstrained fn __normalize_limbs<let NumSegments: u32>(x: ArrayX<Field, N, NumSegments>, range: u32) -> ArrayX<Field, N, NumSegments> {\n        let mut normalized: ArrayX<Field, N, NumSegments> = ArrayX::new();\n        let mut inp = x;\n        // (9 limb mul = 17 product terms)\n\n        // a2 a1 a0\n        // b2 b1 b0\n\n        // a0b0\n        // a1b0 a0b1\n        // a2b0 a1b1 a0b2\n        // a2b1 a1b2\n        // a2b2\n\n        // r0 lo\n        // r0 hi + r1 lo\n        // r1 hi + r2 lo\n        // r2 hi + r3 lo\n        // r3 hi + r4 lo\n        // r4 hi = 6?\n        for i in 0..(range - 1) {\n            let (lo, hi) = split_bits::split_120_bits(inp.get(i));\n\n            normalized.set(i, lo);\n            inp.set(i + 1, inp.get(i + 1) + hi);\n        }\n        {\n            let (lo, hi) = split_bits::split_120_bits(inp.get(range - 1));\n            normalized.set(range - 1, lo);\n            assert(hi == 0);\n        }\n        normalized\n    }\n}\n","path":"/home/hdvanegasm/nargo/github.com/noir-lang/noir-bignumv0.3.0/src/utils/arrayX.nr"},"60":{"source":"use dep::std;\n\nuse crate::utils::arrayX::ArrayX;\nuse crate::utils::split_bits;\nuse crate::utils::msb::get_msb64;\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\nstruct U60Repr<let N: u32, let NumSegments: u32>\n{\n    limbs: ArrayX<u64, N, NumSegments>\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n\n        let mut carry: u64 = 0;\n        for j in 0..NumSegments {\n            for i in 0..N {\n                let mut add: u64 = self.limbs.segments[j][i] + b.limbs.segments[j][i] + carry;\n                carry = add >> 60;\n                add = add - (carry << 60);\n                result.limbs.segments[j][i] = add;\n            }\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for j in 0..NumSegments {\n            for i in 0..N {\n                borrow = ((b.limbs.segments[j][i] + borrow_in) > self.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + self.limbs.segments[j][i] - b.limbs.segments[j][i] - borrow_in;\n                result.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> { \n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n        for i in 0..(N) {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs.set(2 * i, lo);\n            result.limbs.set(2 * i + 1, hi);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs.get(2 * i) as Field + (x.limbs.get(2 * i + 1) as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> { \n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    unconstrained fn new<let NumFieldSegments: u32>(x: ArrayX<Field, N, NumFieldSegments>) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x.get(i));\n            result.limbs.set(2 * i, lo);\n            result.limbs.set(2 * i + 1, hi);\n        }\n        result\n    }\n\n    unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n        result.limbs.set(0, 1);\n        result\n    }\n\n    unconstrained fn into_arrayX<let NumFieldSegments: u32>(x: U60Repr<N, NumSegments>) -> ArrayX<Field, N, NumFieldSegments> {\n        let mut result: ArrayX<Field, N, NumFieldSegments> = ArrayX { segments: [[0; N]; NumFieldSegments] };\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumFieldSegments) {\n            result.set(\n                i,\n                x.limbs.get(2 * i) as Field + (x.limbs.get(2 * i + 1) as Field * two_pow_60)\n            );\n        }\n        result\n    }\n\n    unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs.get((N * NumSegments) - 1 - i) < (self.limbs.get((N * NumSegments) - 1 - i))) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (b.limbs.get((N * NumSegments) - 1 - i) != (self.limbs.get((N * NumSegments) - 1 - i))) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs.get(0) == b.limbs.get(0));\n        }\n        result\n    }\n\n    fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs.get(segment_index);\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs.set(\n            0,\n            (self.limbs.get(0 + num_shifted_limbs) >> limb_shift as u8)\n        );\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs.get(i + num_shifted_limbs);\n            result.limbs.set(i, (value >> limb_shift as u8));\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shr1(&mut self) {\n        let value = self.limbs.segments[NumSegments - 1][N - 1];\n        self.limbs.segments[NumSegments - 1][N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for j in 0..NumSegments {\n            for i in 0..N {\n                let value = self.limbs.segments[NumSegments - 1 - j][N - 1 - i];\n                self.limbs.segments[NumSegments - 1 - j][N - 1 - i] = (value >> 1) + remainder;\n                remainder = (value << 59) & 0x800000000000000;\n            }\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: ArrayX { segments: [[0; N]; NumSegments] } };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs.get(0);\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs.set(num_shifted_limbs, (value << limb_shift) & mask);\n\n        // shift 84. num shifted = 1\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs.get(i);\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs.set(i + num_shifted_limbs, upshift);\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs.segments[0][0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs.segments[0][0] = add;\n        for i in 1..N {\n            let mut add: u64 = self.limbs.segments[0][i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs.segments[0][i] = add;\n        }\n        for j in 1..NumSegments {\n            for i in 0..N {\n                let mut add: u64 = self.limbs.segments[j][i] + carry;\n                carry = add >> 60;\n                add = add - (carry << 60);\n                self.limbs.segments[j][i] = add;\n            }\n        }\n    }\n\n    unconstrained  fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs.get((N * NumSegments) - 1 - i);\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/home/hdvanegasm/nargo/github.com/noir-lang/noir-bignumv0.3.0/src/utils/u60_representation.nr"},"62":{"source":"\n// Decomposes a single field into two 120 bit fields and a carry\nunconstrained pub fn split_120_bits(x: Field) -> (Field, Field) {\n    let x_bytes: [u8] = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let offsets: [Field; 17] = [\n        1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000, 0x10000000000000000, 0x1000000000000000000, 0x100000000000000000000, 0x10000000000000000000000, 0x1000000000000000000000000, 0x100000000000000000000000000, 0x10000000000000000000000000000, 0x1000000000000000000000000000000, 0x100000000000000000000000000000000\n    ];\n\n    for i in 0..15 {\n        low += (x_bytes[i] as Field) * offsets[i];\n        high += (x_bytes[i + 15] as Field) * offsets[i];\n    }\n    high += (x_bytes[30] as Field) * offsets[15];\n    high += (x_bytes[31] as Field) * offsets[16];\n    // TDOO: investigate why this is triggered in BigCurve crate? it shouldn't be?\n    //   assert(x_bytes[31] == 0);\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\nunconstrained pub fn split_60_bits(x: Field) -> (u64, u64) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: u64 = 0;\n    let mut high: u64 = 0;\n\n    let offsets: [u64; 8] = [1, 0x100, 0x10000, 0x1000000, 0x100000000, 0x10000000000, 0x1000000000000, 0x100000000000000];\n    for i in 0..8 {\n        low += (x_bytes[i] as u64) * offsets[i];\n        high += (x_bytes[i + 8] as u64) * offsets[i];\n    }\n    let t1 = low >> 60;\n    let mask = ((1 as u64) << 60 as u8) - 1;\n    low = low & mask;\n    high = (high << 4) | t1;\n    (low, high)\n}\n","path":"/home/hdvanegasm/nargo/github.com/noir-lang/noir-bignumv0.3.0/src/utils/split_bits.nr"},"64":{"source":"use dep::std;\nuse crate::utils::u60_representation::U60Repr;\nuse crate::utils::arrayX::ArrayX;\nuse crate::utils::split_bits;\nuse crate::BigNum;\n\n/**\n * @brief runtime_bignum::BigNumTrait defines methods available to BigNum *if* the modulus is not known at compile time.\n *        e.g. RSA where the modulus is a witness value as it changes for every RSA signature\n *        tee `lib.nr` for a trait definition where the modulus is known at compile time\n **/\ntrait BigNumTrait {\n    fn new() -> Self;\n    fn one() -> Self;\n    fn from(limbs: [Field]) -> Self;\n    fn from_byte_be<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    fn to_le_bytes<let NBytes: u32>(val: Self) -> [u8; NBytes];\n    fn get(self) -> [Field];\n    fn get_limb(self, idx: u64) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn validate_in_range(self);\n    fn validate_quotient_in_range(self);\n    fn __is_zero(self) -> bool;\n    fn __eq(self, rhs: Self) -> bool;\n}\n\n/**\n * @brief BigNumInstanceTrait defines methods available to a runtime BigNumInstance.\n *        BigNumInstance wraps the modulus parameter (as well as a Barret reduction parameter),\n *        which is required for the majority of BigNum operations\n **/\ntrait BigNumInstanceTrait<BN> where BN: BigNumTrait {\n    fn modulus(self) -> BN;\n    fn __derive_from_seed<let SeedBytes: u32>(self, seed: [u8; SeedBytes]) -> BN;\n    fn eq(self, lhs: BN, rhs: BN) -> bool;\n    fn __neg(self, val: BN) -> BN;\n    fn __add(self, lhs: BN, rhs: BN) -> BN;\n    fn __sub(self, lhs: BN, rhs: BN) -> BN;\n    fn __mul(self, lhs: BN, rhs: BN) -> BN;\n    fn __div(self, lhs: BN, rhs: BN) -> BN;\n    fn __batch_invert<let M: u32>(self, x: [BN; M]) -> [BN; M];\n    fn __batch_invert_slice(self, x: [BN]) -> [BN];\n    fn __udiv_mod(self, numerator: BN, divisor: BN) -> (BN, BN);\n    fn __invmod(self, val: BN) -> BN;\n    fn __pow(self, val: BN, exponent: BN) -> BN;\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BN; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BN; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BN; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BN, BN);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BN; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BN; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BN; ADD_N],\n        linear_flags: [bool; ADD_N]\n    );\n\n    fn validate_in_field(self, val: BN);\n    fn validate_gt(self, lhs: BN, rhs: BN);\n    fn assert_is_not_equal(self, lhs: BN, rhs: BN);\n    fn neg(self, val: BN) -> BN;\n    fn add(self, lhs: BN, rhs: BN) -> BN;\n    fn sub(self, lhs: BN, rhs: BN) -> BN;\n    fn mul(self, lhs: BN, rhs: BN) -> BN;\n    fn div(self, lhs: BN, rhs: BN) -> BN;\n    fn udiv_mod(self, numerator: BN, divisor: BN) -> (BN, BN);\n    fn udiv(self, numerator: BN, divisor: BN) -> BN;\n    fn umod(self, numerator: BN, divisor: BN) -> BN;\n\n}\n\n/**\n * @brief BigNumParamsTrait defines a \"field\" with which to parametrise BigNum.\n * @description The \"field\" does not need to be prime, any value *should* work (TODO: test!)\n**/\ntrait BigNumParamsTrait<let N: u32> {\n    /**\n     * @brief modulus_bits = log2(modulus) rounded up\n     **/\n    fn modulus_bits() -> u32;\n\n    fn has_multiplicative_inverse() -> bool { true }\n}\n\nstruct BigNumInstance<let N: u32, Params> {\n    \n    /**\n     * @brief modulus: all BigNum operations are evaluated modulo this value\n     **/\n    modulus: [Field; N],\n\n    /**\n     * @brief modulus but represented in a U60Repr form\n     **/\n    modulus_u60: U60Repr<N, 2>,\n    modulus_u60_x4: U60Repr<N, 4>,\n\n    // /**\n    //  * @brief double_modulus: used when performing negations and subtractions\n    //  **/\n    double_modulus: [Field; N],\n    // /**\n    //  * @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    //  **/\n    redc_param: [Field; N],\n}\n\nimpl<let N: u32, Params> BigNum<N, Params> {\n    // some strange circular dependency problem means we need to define `new` as a member of BigNumTrait as well as a definition outside of the trait\n    // (delete this method to see. BigNumInstance methods that use BigNum::new() error out, and I can't find a way of declaring BigNum to satisfy BigNumTrait as part of the BigNumInstance definition because BigNumInstance has no contextual knowledge of the BigNum type...)\n    fn new() -> Self {\n        BigNum { limbs: [0; N] }\n    }\n    fn one() -> BigNum<N, Params> {\n        let mut result: Self = BigNum { limbs: [0; N] };\n        result.limbs[0] = 1;\n        result\n    }\n}\n\nimpl<let N: u32, Params> BigNumTrait for BigNum<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn new() -> Self {\n        BigNum::new()\n    }\n    fn one() -> Self {\n        BigNum::one()\n    }\n\n    fn from(limbs: [Field]) -> Self { BigNum{ limbs: limbs.as_array() }}\n\n    /**\n     * @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n     * @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n     *               is precisely large enough to cover Params::modulus_bits()\n     * @param x: input byte array\n     **/\n    fn from_byte_be<let NBytes: u32>(x: [u8; NBytes]) -> BigNum<N, Params> {\n        let num_bits = NBytes * 8;\n        let modulus_bits = Params::modulus_bits();\n        assert(num_bits > modulus_bits);\n        assert(num_bits - modulus_bits < 8);\n        let mut result = BigNum::new();\n\n        let excess_bytes = N * 15 - NBytes;\n        let final_limb_bytes = 15 - excess_bytes;\n        let mut limb: Field = 0;\n        let mut k = 0;\n        for _j in 0..final_limb_bytes {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result.limbs[N - 1] = limb;\n\n        for i in 1..N {\n            let mut limb: Field = 0;\n            for _j in 0..15 {\n                limb *= 256;\n                limb += x[k] as Field;\n                k += 1;\n            }\n            result.limbs[N - i - 1] = limb;\n        }\n\n        // max_bits_in_most_significant_byte should be known at comptime. if not...messy!\n        let mut max_bits_in_most_significant_byte = num_bits - modulus_bits;\n        if num_bits == modulus_bits {\n            max_bits_in_most_significant_byte = 8;\n        }\n\n        let most_significant_byte: Field = x[NBytes - 1] as Field;\n        most_significant_byte.assert_max_bit_size(max_bits_in_most_significant_byte as u32);\n        result\n    }\n\n    fn to_le_bytes<let NBytes: u32>(val: BigNum<N, Params>) -> [u8; NBytes] {\n        let nbytes = (Params::modulus_bits() / 8) + (Params::modulus_bits() % 8 != 0) as u32;\n        assert(nbytes <= NBytes);\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..N - 1 {\n            let limb_bytes = val.limbs[i].to_le_bytes(15);\n            for j in 0..15 {\n                result[i * 15 + j] = limb_bytes[j];\n            }\n        }\n        let last_limb_bytes = val.limbs[N - 1].to_le_bytes(15);\n        let num_last_bytes = (NBytes - (N - 1) * 15);\n        for i in 0..num_last_bytes {\n            result[(N-1) * 15 + i] = last_limb_bytes[i];\n        }\n        result\n    }\n\n    fn get(self) -> [Field] {\n        self.limbs\n    }\n    fn get_limb(self, idx: u64) -> Field {\n        self.limbs[idx]\n    }\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    /**\n     * @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n     * @description should be cheaper than using an IF statement (TODO: check!)\n     **/\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let mut result: Self = lhs;\n        for i in 0..N {\n            result.limbs[i] = (lhs.limbs[i] - rhs.limbs[i]) * predicate as Field + rhs.limbs[i];\n        }\n        result\n    }\n\n    /**\n     * @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n     **/\n    fn validate_in_range(self) {\n        for i in 0..(N - 1) {\n            self.limbs[i].assert_max_bit_size(120);\n        }\n        let final_limb_bits = Params::modulus_bits() - ((N - 1) * 120);\n        self.limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n    }\n\n    /**\n     * @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n     * @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n     *              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n     *              Why is this?\n     *              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n     *                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n     *                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n     *              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n     *\n     *              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n     *              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n     **/\n    fn validate_quotient_in_range(self) {\n        for i in 0..(N) {\n            self.limbs[i].assert_max_bit_size(120);\n        }\n        // Note: replace magic number 6 with definition\n        let final_limb_bits = Params::modulus_bits() - ((N - 1) * 120) + 6;\n        self.limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n    }\n\n    fn __is_zero(self) -> bool {\n        self.__is_zero_impl()\n    }\n\n    fn __eq(self, rhs: Self) -> bool {\n        self.__eq_impl(rhs)\n    }\n}\n\nimpl<let N: u32, Params> BigNum<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn from_array(limbs: [Field; N]) -> BigNum<N, Params> {\n        BigNum { limbs }\n    }\n\n    unconstrained fn __is_zero_impl(self) -> bool {\n        let mut result: bool = true;\n        for i in 0..N {\n            result = result & (self.limbs[i] == 0);\n        }\n        result\n    }\n\n    unconstrained fn __eq_impl(lhs: Self, rhs: Self) -> bool {\n        lhs.limbs == rhs.limbs\n    }\n}\n\nimpl<let N: u32, Params,> BigNumInstanceTrait<BigNum<N, Params>> for BigNumInstance<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn modulus(self) -> BigNum<N, Params> { BigNum{ limbs: self.modulus } }\n    fn __derive_from_seed<let SeedBytes: u32>(self, seed: [u8; SeedBytes]) -> BigNum<N, Params> {\n        self.__derive_from_seed_impl(seed)\n    }\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### U N C O N S T R A I N E D    F U N C T I O N S\n    // ### NOTE: these functions call unconstrained internal implementations because trait impl modifiers are not supported \n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    fn __neg(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__neg_impl(val)\n    }\n\n    fn __add(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__add_impl(lhs, rhs)\n    }\n\n    fn __sub(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__sub_impl(lhs, rhs)\n    }\n\n    fn __mul(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__mul_impl(lhs, rhs)\n    }\n\n    fn __div(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__div_impl(lhs, rhs)\n    }\n\n    fn __batch_invert<let M: u32>(self, x: [BigNum<N, Params>; M]) -> [BigNum<N, Params>; M] {\n        self.batch_invert_impl(x)\n    }\n\n    // n.b. needs to be declared unconstrained because we return a slice from an unconstrained runtime\n    unconstrained fn __batch_invert_slice(self, x: [BigNum<N, Params>]) -> [BigNum<N, Params>] {\n        self.batch_invert_slice_impl(x)\n    }\n\n    fn __invmod(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__invmod_impl(val)\n    }\n\n    fn __pow(self, val: BigNum<N, Params>, exponent: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__pow_impl(val, exponent)\n    }\n\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n            self,\n            lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n            lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n            rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n            rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n            linear_terms: [BigNum<N, Params>; ADD_N],\n            linear_flags: [bool; ADD_N]\n        ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n            self.__compute_quadratic_expression_impl(\n                lhs_terms,\n                lhs_flags,\n                rhs_terms,\n                rhs_flags,\n                linear_terms,\n                linear_flags\n            )\n    }\n\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C O N S T R A I N E D    F U N C T I O N S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n\n    /**\n     * @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n     * @description The expression is of the form (when evaluated as an integer relation):\n     *\n     * \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n     *\n     * The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n     *\n     * Note: this method requires the remainder term of the expression to be ZERO\n     * When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n     * This can be achieved by minimizing the number of degree-2 relations required.\n     *\n     * The expensive parts of this algorithm are the following:\n     *      1. evaluating the limb products required to compute `lhs * rhs`\n     *      2. applying range constraints to validate the result is 0\n     *\n     * Range constraints are needed for the following reason:\n     * When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n     * Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n     * Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n     * To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n     * (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n     * To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n     * We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n     * TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n     * I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n     * TODO: explain why we apply a 126-bit range check, this feels like a magic number\n     * (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n     * TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n     * \n     * @param lhs_terms a 2D array of BigNum\n     * @param lhs_flags a 2D array of sign flags\n     * @param rhs_terms a 2D array of BigNum\n     * @param rhs_flags a 2D array of sign flags\n     * @param linear_terms an array of BigNum\n     * @param linear_flags an array of sign flags\n     **/\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) {\n        // use an unconstrained function to compute the value of the quotient\n        let (quotient, _, borrow_flags): (BigNum<N, Params>, BigNum<N, Params>, ArrayX<Field, N, 2>) = self.__compute_quadratic_expression_with_borrow_flags(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n        // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n        quotient.validate_quotient_in_range();\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        // (should be a compile-time check...unconstrained function?)\n\n        // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n        let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut t4: [Field; N] = [0; N];\n\n        // TODO: this is super nasty as it requires a multiplication\n        let double_modulus: [Field; N] = self.double_modulus;\n        for k in 0..NUM_PRODUCTS {\n            for i in 0..N {\n                for j in 0..LHS_N {\n                    // note: if is_negative is not known at comptime this is very expensive\n                    if (lhs_flags[k][j]) {\n                        t0[k][i] -= lhs_terms[k][j].limbs[i];\n                        t0[k][i] += double_modulus[i];\n                    } else {\n                        t0[k][i] += lhs_terms[k][j].limbs[i];\n                    }\n                }\n                for j in 0..RHS_N {\n                    if (rhs_flags[k][j]) {\n                        t1[k][i] -= rhs_terms[k][j].limbs[i];\n                        t1[k][i] += double_modulus[i];\n                    } else {\n                        t1[k][i] += rhs_terms[k][j].limbs[i];\n                    }\n                }\n            }\n        }\n        for i in 0..N {\n            for j in 0..ADD_N {\n                if (linear_flags[j]) {\n                    t4[i] -= linear_terms[j].limbs[i];\n                    t4[i] += double_modulus[i];\n                } else {\n                    t4[i] += linear_terms[j].limbs[i];\n                }\n            }\n        }\n\n        // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n        // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n        // so that we can ensure that no limbs will underflow for an honest Prover\n        let mut product_limbs: ArrayX<Field, N,2> = ArrayX::new();\n        //       let fff: [Field; N] = quotient.limbs;\n        //      let mut borrow_flags: ArrayX<Field, N,2> = BigNum::get_borrow_flags3(t0, t1, t2, t3, t4, fff, self.modulus);\n\n        // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n        // TODO: this is super nasty as it requires a multiplication\n        for i in 0..N {\n            for j in 0..N {\n                for k in 0..NUM_PRODUCTS {\n                    if k == 0 {\n                        let new_term = t0[k][i] * t1[k][j] - quotient.limbs[i] * self.modulus[j];\n                        std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                        product_limbs.add_assign(i + j, new_term);\n                    } else {\n                        product_limbs.add_assign(i + j, t0[k][i] * t1[k][j]);\n                    }\n                }\n                if (NUM_PRODUCTS == 0) {\n                    product_limbs.sub_assign(i + j, quotient.limbs[i] * self.modulus[j]);\n                }\n            }\n            product_limbs.add_assign(i, t4[i]);\n        }\n\n        // each limb product represents the sum of 120-bit products.\n        // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n        // where no more than 64 limb products are summed together.\n        // TODO: check in unconstrained function that this condition is satisfied\n        // TODO: define trade-offs regarding the value of borrow_shift\n        // (the larger the value, the greater the range check that is required on product_limbs)\n        // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n        // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n        let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n        let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n\n        // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n        //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n        // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n        borrow_flags.get(0).assert_max_bit_size(1);\n        product_limbs.add_assign(0, borrow_flags.get(0) * borrow_shift);\n        for i in 1..(N + N - 2) {\n            borrow_flags.get(i).assert_max_bit_size(1);\n            product_limbs.add_assign(\n                i,\n                (borrow_flags.get(i) * borrow_shift - borrow_flags.get(i - 1) * borrow_carry)\n            );\n        }\n        product_limbs.sub_assign(N + N - 2, borrow_flags.get(N + N - 3) * borrow_carry);\n\n        // Final step: Validate `product_limbs` represents the integer value `0`\n        // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n        // i.e. we need to do the following for each limb `i`:\n        //      1. validate the limb's low-120 bits equals zero\n        //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n        //      3. add the carry into limb `i+1`\n        // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n        // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n        // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n        //  where k is the number of bits in the prime field)\n        // We then add the result into the next limb and repeat.\n        let hi_shift: Field = 0x1000000000000000000000000000000;\n        let hi_downshift: Field = 1 / hi_shift;\n        for i in 0..N + N - 2 {\n            product_limbs.mul_assign(i, hi_downshift);\n            std::as_witness(product_limbs.get(i));\n            product_limbs.get(i).assert_max_bit_size(126); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n            product_limbs.add_assign(i + 1, product_limbs.get(i));\n        }\n        // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n        assert(product_limbs.get(N + N - 2) == 0);\n    }\n\n    fn validate_in_field(self, val: BigNum<N, Params>) {\n        // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n        let mut p_minus_self: [Field; N] = [0; N];\n        let modulus: [Field; N] = self.modulus;\n        for i in 0..N {\n            p_minus_self[i] = modulus[i] - val.limbs[i];\n        }\n        let borrow_flags = self.__validate_in_field_compute_borrow_flags(val);\n        let two_pow_120: Field = 0x1000000000000000000000000000000;\n        p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n        for i in 1..N - 1 {\n            p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i-1] as Field);\n        }\n        p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n        let mut compare = val;\n        compare.limbs = p_minus_self;\n        compare.validate_in_range();\n    }\n\n    /**\n     * @brief Validate self != other\n     * @details If A == B, then A == B mod N.\n     *          We can efficiently evaluate A == B mod N where N = circuit modulus\n     *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n     *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n     *          (todo: compute how tiny)\n     **/\n    fn assert_is_not_equal(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) {\n        let mut l: Field = 0;\n        let mut r: Field = 0;\n        let mut modulus_mod_n: Field = 0;\n        let mut two_pow_120: Field = 0x1000000000000000000000000000000;\n        let modulus = self.modulus;\n        for i in 0..N {\n            l *= two_pow_120;\n            r *= two_pow_120;\n            modulus_mod_n *= two_pow_120;\n            l += lhs.limbs[N - i - 1];\n            r += rhs.limbs[N - i - 1] ;\n            modulus_mod_n += modulus[N - i - 1];\n        }\n\n        // lhs can be either X mod N or P + X mod N\n        // rhs can be either Y mod N or P + Y mod N\n        // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n        let mut diff = l - r;\n        let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n        assert(target != 0, \"asssert_is_not_equal fail\");\n    }\n\n    fn eq(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> bool {\n        let diff = self.sub(lhs, rhs);\n        // if self == other, possible values of `diff` will be `p` or `0`\n        // (the subtract operator constrains diff to be < ceil(log(p)))\n        // TODO: can do this more efficiently via witngen in unconstrained functions?\n        let mut is_equal_modulus: bool = true;\n        let mut is_equal_zero: bool = true;\n        for i in 0..N {\n            is_equal_modulus = is_equal_modulus & (diff.limbs[i] == self.modulus[i]);\n            is_equal_zero = is_equal_zero & (diff.limbs[i] == 0);\n        }\n        is_equal_modulus | is_equal_zero\n    }\n\n    fn neg(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = self.__neg_with_flags(val);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let result_limb = modulus[0] - val.limbs[0] - result.limbs[0] + (borrow_flags[0] as Field * borrow_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val.limbs[i] - result.limbs[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val.limbs[N - 1] - result.limbs[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n\n    fn add(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) = self.__add_with_flags(lhs, rhs);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let carry_shift = 0x1000000000000000000000000000000;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let result_limb = lhs.limbs[0] + rhs.limbs[0] - subtrahend[0] - result.limbs[0]\n            + (borrow_flags[0] as Field * borrow_shift)\n            - (carry_flags[0] as Field * carry_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = lhs.limbs[i] + rhs.limbs[i]\n                - subtrahend[i]\n                - result.limbs[i]\n                - borrow_flags[i - 1] as Field\n                + carry_flags[i - 1] as Field\n                + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = lhs.limbs[N - 1] + rhs.limbs[N - 1]\n            - subtrahend[N - 1]\n            - result.limbs[N - 1]\n            - borrow_flags[N - 2] as Field\n            + carry_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n\n    // validate that lhs - rhs does not underflow i.e. lhs > rhs\n    fn validate_gt(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) {\n        // so we do... p - x - r = 0 and there might be borrow flags\n\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags) = self.__validate_gt_remainder(lhs, rhs);\n\n        result.validate_in_range();\n\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let carry_shift = 0x1000000000000000000000000000000;\n\n        let mut addend: [Field; N] = [0; N];\n        let result_limb = lhs.limbs[0] - rhs.limbs[0] + addend[0] - result.limbs[0] - 1\n            + (borrow_flags[0] as Field * borrow_shift)\n            - (carry_flags[0] as Field * carry_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = lhs.limbs[i] - rhs.limbs[i] + addend[i] - result.limbs[i] - borrow_flags[i - 1] as Field\n                + carry_flags[i - 1] as Field\n                + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = lhs.limbs[N - 1] - rhs.limbs[N - 1] + addend[N - 1]\n            - result.limbs[N - 1]\n            - borrow_flags[N - 2] as Field\n            + carry_flags[N - 2] as Field;\n        assert(result_limb == 0);\n    }\n\n    fn sub(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) = self.__sub_with_flags(lhs, rhs);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let carry_shift = 0x1000000000000000000000000000000;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n        let result_limb = lhs.limbs[0] - rhs.limbs[0] + addend[0] - result.limbs[0]\n            + (borrow_flags[0] as Field * borrow_shift)\n            - (carry_flags[0] as Field * carry_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = lhs.limbs[i] - rhs.limbs[i] + addend[i] - result.limbs[i] - borrow_flags[i - 1] as Field\n                + carry_flags[i - 1] as Field\n                + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = lhs.limbs[N - 1] - rhs.limbs[N - 1] + addend[N - 1]\n            - result.limbs[N - 1]\n            - borrow_flags[N - 2] as Field\n            + carry_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let result = self.__mul(lhs, rhs);\n        self.evaluate_quadratic_expression([[lhs]], [[false]], [[rhs]], [[false]], [result], [true]);\n        result\n    }\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        assert(Params::has_multiplicative_inverse(), \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\");\n        let result = self.__div(lhs, rhs);\n        self.evaluate_quadratic_expression([[result]], [[false]], [[rhs]], [[false]], [lhs], [true]);\n        result\n    }\n\n    /**\n     * @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n     *\n     * i.e. 1. floor(numerator / divisor) = quotient\n     *      2. numerator % divisor = remainder\n     *      3. divisor * quotient + remainder = numerator\n     **/\n    fn __udiv_mod(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        self.__udiv_mod_impl(numerator, divisor)\n    }\n    /**\n     * @brief udiv_mod performs integer division between numerator, divisor \n     *\n     * i.e. 1. floor(numerator / divisor) = quotient\n     *      2. numerator % divisor = remainder\n     *      3. divisor * quotient + remainder = numerator\n     **/\n    fn udiv_mod(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        let (quotient, remainder) = BigNumInstance::__udiv_mod_impl(self, numerator, divisor);\n\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        self.evaluate_quadratic_expression(\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false]\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        self.validate_gt(divisor, remainder);\n        (quotient, remainder)\n    }\n\n    /**\n     * @brief udiv_mod performs integer division between numerator, divisor \n     *\n     * i.e. return param is floor(numerator / divisor)\n     **/\n    fn udiv(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.udiv_mod(numerator, divisor).0\n    }\n\n    /**\n     * @brief udiv_mod performs integer modular reduction\n     *\n     * i.e. 1. numerator % divisor = return value\n     **/\n    fn umod(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.udiv_mod(numerator, divisor).1\n    }\n\n}\n\nimpl<let N: u32, Params> BigNumInstance<N, Params> where Params: BigNumParamsTrait<N> {\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C  O  N  S  T  R  U  C  T  O  R  S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    fn new(modulus: [Field; N], redc_param: [Field; N]) -> Self {\n        Self {\n            redc_param,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus)\n        }\n    }\n\n    unconstrained fn __derive_from_seed_impl<let SeedBytes: u32>(self, seed: [u8; SeedBytes]) -> BigNum<N, Params> {\n        let mut rolling_seed = seed;\n\n        let mut to_reduce: ArrayX<Field, N, 2> = ArrayX { segments: [[0; N], [0; N]] };\n\n        let mut double_modulus_bits = Params::modulus_bits() * 2;\n        let mut double_modulus_bytes = (double_modulus_bits) / 8 + (double_modulus_bits % 8 != 0) as u32;\n\n        let mut last_limb_bytes = double_modulus_bytes % 15;\n        if (last_limb_bytes == 0) {\n            last_limb_bytes = 15;\n        }\n        let mut last_limb_bits = double_modulus_bits % 8;\n        if (last_limb_bits == 0) {\n            last_limb_bits = 8;\n        }\n\n        for i in 0..(N - 1) {\n            let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n            for j in 0..15 {\n                hi *= 256;\n                lo *= 256;\n\n                if (i < 2 * N - 2) {\n                    lo += hash[j + 15] as Field;\n                    hi += hash[j] as Field;\n                }\n            }\n            to_reduce.set(2 * i, lo);\n            to_reduce.set(2 * i + 1, hi);\n            rolling_seed[0] += 1;\n        }\n\n        {\n            let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n            let mut hi: Field = 0;\n            for j in 0..(last_limb_bytes - 1) {\n                hi *= 256;\n                hi += hash[j] as Field;\n            }\n            hi *= 256;\n            let last_byte = hash[last_limb_bytes - 1];\n            let mask = (1 as u64 << (last_limb_bits) as u8) - 1;\n            let last_bits = last_byte as u64 & mask;\n            hi += last_bits as Field;\n            to_reduce.set(2 * N - 2, hi);\n        }\n\n        let (_, remainder) = __barrett_reduction(\n            to_reduce,\n            self.redc_param,\n            Params::modulus_bits(),\n            self.modulus,\n            self.modulus_u60_x4\n        );\n        let mut result = BigNum::new();\n        result.limbs = remainder;\n        result\n    }\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### U N C O N S T R A I N E D    F U N C T I O N S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    unconstrained fn __validate_in_field_compute_borrow_flags(self: Self, val: BigNum<N, Params>) -> [bool; N] {\n        let mut flags: [bool; N] = [false; N];\n        let modulus: [Field; N] = self.modulus;\n        flags[0] = modulus[0].lt(val.limbs[0]);\n        for i in 1..N - 1 {\n            flags[i] = modulus[i].lt(val.limbs[i] + flags[i - 1] as Field);\n        }\n        flags\n    }\n\n    unconstrained fn __pow_impl(self, val: BigNum<N, Params>, exponent: BigNum<N, Params>) -> BigNum<N, Params> {\n        let x: U60Repr<N, 2> = U60Repr::from(exponent.limbs);\n\n        let num_bits = Params::modulus_bits() + 1;\n\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n\n        for i in 0..num_bits {\n            accumulator = self.__mul(accumulator, accumulator);\n            if x.get_bit(num_bits - i - 1) {\n                accumulator = self.__mul(accumulator, val);\n            }\n        }\n        accumulator\n    }\n\n    unconstrained fn __mul_with_quotient(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        let mut mul: ArrayX<Field, N, 2> = ArrayX::new();\n        for i in 0..N {\n            for j in 0..N {\n                mul.add_assign(i + j, lhs.limbs[i] * rhs.limbs[j]);\n            }\n        }\n        let (q, r) = __barrett_reduction(\n            mul.__normalize_limbs(N + N),\n            self.redc_param,\n            Params::modulus_bits(),\n            self.modulus,\n            self.modulus_u60_x4\n        );\n\n        let mut quotient = BigNum::from_array(q);\n        let mut remainder = BigNum::from_array(r);\n        (quotient, remainder)\n    }\n\n    unconstrained fn __mul_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let (_, b) = self.__mul_with_quotient(lhs, rhs);\n        b\n    }\n\n    unconstrained fn __add_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let y_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n\n        let mut z_u60 = x_u60 + y_u60;\n\n        if z_u60.gte(self.modulus_u60) {\n            z_u60 = z_u60 - self.modulus_u60;\n        }\n        let mut result = BigNum::from_array(U60Repr::into(z_u60));\n        result\n    }\n\n    /**\n     * @brief given an input `x`, compute `2p - x` (unconstrained)\n     *\n     * @description we subtract the input from double the modulus, because all constrained BigNum operations\n     *              only guarantee that the output is in the range [0, ceil(log2(p))].\n     *              I.E. the input may be larger than the modulus `p`.\n     *              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n     *              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n     *              because such a check is expensive and usually unneccesary.\n     */\n    unconstrained fn __neg_impl(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        let f: [Field; N] = val.limbs;\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n        let mut result = BigNum::from_array(U60Repr::into(self.modulus_u60 - x_u60));\n        result\n    }\n\n    unconstrained fn __add_with_flags(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, [bool; N], [bool; N], bool) {\n        let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n        let add_u60 = a_u60 + b_u60;\n\n        let overflow = add_u60.gte(self.modulus_u60);\n\n        let mut subtrahend_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        if overflow {\n            subtrahend_u60 = self.modulus_u60;\n        }\n\n        let mut carry: u64 = 0;\n        let mut carry_in: u64 = 0;\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n        let mut borrow_flags: [bool; N] = [false; N];\n        let mut carry_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                let mut add_term: u64 = a_u60.limbs.segments[j][i] + b_u60.limbs.segments[j][i] + carry_in;\n                carry = (add_term >= 0x1000000000000000) as u64;\n                add_term -= (carry as u64 * 0x1000000000000000);\n                result_u60.limbs.segments[j][i] = add_term;\n                carry_in = carry as u64;\n                borrow = ((subtrahend_u60.limbs.segments[j][i] + borrow_in) > result_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + result_u60.limbs.segments[j][i]\n                    - subtrahend_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    if (carry & borrow == 1) {\n                        carry = 0;\n                        borrow = 0;\n                    }\n                    carry_flags[idx] = carry as bool;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n\n        (result, carry_flags, borrow_flags, overflow)\n    }\n\n    unconstrained fn __validate_gt_remainder(\n        _: Self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, [bool; N], [bool; N]) {\n        let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let mut b_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n\n        let underflow = b_u60.gte(a_u60);\n        b_u60 += U60Repr::one();\n        assert(underflow == false, \"BigNum::validate_gt check fails\");\n        let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        let mut carry: u64 = 0;\n        let mut carry_in: u64 = 0;\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n        let mut borrow_flags: [bool; N] = [false; N];\n        let mut carry_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                let mut add_term: u64 = a_u60.limbs.segments[j][i] + addend_u60.limbs.segments[j][i] + carry_in;\n                carry = (add_term >= 0x1000000000000000) as u64;\n                add_term -= (carry as u64 * 0x1000000000000000);\n                result_u60.limbs.segments[j][i] = add_term;\n                carry_in = carry as u64;\n                borrow = ((b_u60.limbs.segments[j][i] + borrow_in) > result_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + result_u60.limbs.segments[j][i]\n                    - b_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    if (carry & borrow == 1) {\n                        carry = 0;\n                        borrow = 0;\n                    }\n                    carry_flags[idx] = carry as bool;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n        (result, carry_flags, borrow_flags)\n    }\n\n\n    unconstrained fn __sub_with_flags(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, [bool; N], [bool; N], bool) {\n        let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n\n        let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n        let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        if underflow {\n            addend_u60 = self.modulus_u60;\n        }\n\n        let mut carry: u64 = 0;\n        let mut carry_in: u64 = 0;\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n        let mut borrow_flags: [bool; N] = [false; N];\n        let mut carry_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                let mut add_term: u64 = a_u60.limbs.segments[j][i] + addend_u60.limbs.segments[j][i] + carry_in;\n                carry = (add_term >= 0x1000000000000000) as u64;\n                add_term -= (carry as u64 * 0x1000000000000000);\n                result_u60.limbs.segments[j][i] = add_term;\n                carry_in = carry as u64;\n                borrow = ((b_u60.limbs.segments[j][i] + borrow_in) > result_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + result_u60.limbs.segments[j][i]\n                    - b_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    if (carry & borrow == 1) {\n                        carry = 0;\n                        borrow = 0;\n                    }\n                    carry_flags[idx] = carry as bool;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n        (result, carry_flags, borrow_flags, underflow)\n    }\n\n    unconstrained fn __neg_with_flags(self, val: BigNum<N, Params>) -> (BigNum<N, Params>, [bool; N]) {\n        let f: [Field; N] = val.limbs;\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        let mut borrow_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                borrow = ((x_u60.limbs.segments[j][i] + borrow_in) > self.modulus_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + self.modulus_u60.limbs.segments[j][i]\n                    - x_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n        (result, borrow_flags)\n    }\n\n    /**\n     * @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n     * @description see `__neg` for why we use 2p instead of p\n     **/\n    unconstrained fn __sub_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__add(lhs, self.__neg(rhs))\n    }\n\n    unconstrained fn __invmod_impl(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        let one: BigNum<N, Params> = BigNum::one();\n        let one_u60: U60Repr<N, 2> = U60Repr::from(one.limbs);\n        let exponent = self.modulus_u60.sub(one_u60.add(one_u60));\n        let mut result = BigNum::from_array(U60Repr::into(exponent));\n        self.__pow(val, result)\n    }\n\n    unconstrained fn batch_invert_impl<let M: u32>(self, x: [BigNum<N, Params>; M]) -> [BigNum<N, Params>; M] {\n        // TODO: ugly! Will fail if input slice is empty\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n        let mut result: [BigNum<N, Params>; M] = [BigNum::new(); M];\n        let mut temporaries: [BigNum<N, Params>] = &[];\n        for i in 0..x.len() {\n            temporaries = temporaries.push_back(accumulator);\n            if (x[i].__is_zero() == false) {\n                accumulator = self.__mul(accumulator, x[i]);\n            }\n        }\n\n        accumulator = self.__invmod(accumulator);\n        let mut T0: BigNum<N, Params> = BigNum::new();\n        T0.limbs = [0; N];\n        for i in 0..x.len() {\n            let idx = x.len() - 1 - i;\n            if (x[idx].__is_zero() == false) {\n                T0 = self.__mul(accumulator, temporaries[idx]);\n                accumulator = self.__mul(accumulator, x[idx]);\n                result[idx] = T0;\n            }\n        }\n        result\n    }\n\n    unconstrained fn batch_invert_slice_impl(self, x: [BigNum<N, Params>]) -> [BigNum<N, Params>] {\n        // TODO: ugly! Will fail if input slice is empty\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n        let mut result: [BigNum<N, Params>] = [BigNum::new()];\n        let mut temporaries: [BigNum<N, Params>] = &[];\n        for i in 0..x.len() {\n            temporaries = temporaries.push_back(accumulator);\n            if (x[i].__is_zero() == false) {\n                accumulator = self.__mul(accumulator, x[i]);\n            }\n            result = result.push_back(BigNum::new());\n        }\n\n        accumulator = self.__invmod(accumulator);\n        let mut T0: BigNum<N, Params> = BigNum::new();\n        T0.limbs = [0; N];\n        for i in 0..x.len() {\n            let idx = x.len() - 1 - i;\n            if (x[idx].__is_zero() == false) {\n                T0 = self.__mul(accumulator, temporaries[idx]);\n                accumulator = self.__mul(accumulator, x[idx]);\n                result[idx] = T0;\n            }\n        }\n        result\n    }\n\n    unconstrained fn __div_impl(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> BigNum<N, Params> {\n        let t0 = self.__invmod(divisor);\n        self.__mul(numerator, t0)\n    }\n\n    /**\n     * @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n     **/\n    // NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n    // To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n    // We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n    // Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n    // Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\n    unconstrained fn __add_linear_expression<let M: u32>(\n        self,\n        x: [BigNum<N, Params>; M],\n        flags: [bool; M]\n    ) -> ([Field; N]) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mut sum: [Field; N] = [0; N];\n        // TODO: ugly! Will fail if input array is empty\n        let modulus2: [Field;N] = self.double_modulus;\n        for i in 0..M {\n            if (flags[i]) {\n                for j in 0..N {\n                    sum[j] = sum[j] + modulus2[j] - x[i].limbs[j];\n                    assert(x[i].limbs[j].lt(modulus2[j]));\n                }\n            } else {\n                for j in 0..N {\n                    sum[j] = sum[j] + x[i].limbs[j];\n                }\n            }\n        }\n        // problem if we normalize when used in computing quotient\n        sum\n        //   let result_p: ArrayX<Field, N, 1> = BigNum::__normalize_limbs(ArrayX::from_array(lhs_sum_p), N);\n        //  let result_n: ArrayX<Field, N, 1> = BigNum::__normalize_limbs(ArrayX::from_array(lhs_sum_n), N);\n        //  (result_p.segments[0], result_n.segments[0])\n    }\n\n    /**\n     * @brief computes the limb products of a quadratic expression\n     * @details see __compute_quadratic_expression_with_borrow_flags for full description\n     **/\n    unconstrained fn __compute_quadratic_expression_product<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> ArrayX<Field, N, 2> {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut add: [Field; N] = [0; N];\n\n        for i in 0..NUM_PRODUCTS {\n            lhs[i] = self.__add_linear_expression(lhs_terms[i], lhs_flags[i]);\n            rhs[i]= self.__add_linear_expression(rhs_terms[i], rhs_flags[i]);\n        }\n\n        let add: [Field; N] = self.__add_linear_expression(linear_terms, linear_flags);\n\n        let mut mulout: ArrayX<Field, N,2> = ArrayX::new();\n\n        for i in 0..N {\n            for j in 0..N {\n                for k in 0..NUM_PRODUCTS {\n                    mulout.add_assign(i + j, (lhs[k][i] * rhs[k][j]));\n                }\n            }\n            mulout.add_assign(i, add[i]);\n        }\n        mulout\n    }\n\n    /**\n     * @brief computes the quotient/remainder of a quadratic expression\n     * @details see __compute_quadratic_expression_with_borrow_flags for full description\n     **/\n    unconstrained fn __compute_quadratic_expression_impl<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mulout = self.__compute_quadratic_expression_product(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        let relation_result: ArrayX<Field, N, 2> = mulout.__normalize_limbs(N + N);\n\n        // TODO: ugly! Will fail if input slice is empty\n        let k  = Params::modulus_bits();\n\n        let (quotient, remainder) = __barrett_reduction(\n            relation_result,\n            self.redc_param,\n            k,\n            self.modulus,\n            self.modulus_u60_x4\n        );\n\n        let mut q = BigNum::from_array(quotient);\n        let mut r = BigNum::from_array(remainder);\n        (q, r)\n    }\n\n    /**\n     * @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n     * @description The expression is of the form:\n     *\n     * \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n     *\n     * The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n     *\n     * When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n     * This can be achieved by minimizing the number of degree-2 relations required.\n     *\n     * The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n     * For example, when computing the product a * b - q * p = 0, it is possible that:\n     *      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n     *      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n     * In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n     * In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n     *\n     * @param lhs_terms a 2D array of BigNum\n     * @param lhs_flags a 2D array of sign flags\n     * @param rhs_terms a 2D array of BigNum\n     * @param rhs_flags a 2D array of sign flags\n     * @param linear_terms an array of BigNum\n     * @param linear_flags an array of sign flags\n     **/\n    unconstrained fn __compute_quadratic_expression_with_borrow_flags<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BigNum<N, Params>, BigNum<N, Params>, ArrayX<Field, N, 2>) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n\n        let mut mulout_p = self.__compute_quadratic_expression_product(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        let mut mulout_n: ArrayX<Field, N,2> = ArrayX::new();\n\n        let relation_result: ArrayX<Field, N, 2> = mulout_p.__normalize_limbs(N + N);\n        let modulus: [Field; N] = self.modulus;\n        let (quotient, remainder) = __barrett_reduction(\n            relation_result,\n            self.redc_param,\n            Params::modulus_bits(),\n            modulus,\n            self.modulus_u60_x4\n        );\n        assert(remainder == [0; N]);\n\n        for i in 0..N {\n            for j in 0..N {\n                mulout_n.add_assign(i + j, quotient[i] * modulus[j]);\n            }\n        }\n\n        // compute borrow flags from mulout_p and mulout_n\n        let mut borrow_flags: ArrayX<Field, N, 2> = ArrayX::new();\n        let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n        let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n        let two_pow_120: Field = 0x1000000000000000000000000000000;\n        let downshift: Field = 1 / two_pow_120;\n\n        // determine whether we need to borrow from more significant limbs.\n        // initial limb is \"simple\" comparison operation\n        // TODO: check how expensive `lt` operator is w.r.t. witness generation\n        borrow_flags.set(0, mulout_p.get(0).lt(mulout_n.get(0)) as Field);\n        // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n        // and there is nothing to borrow against for the final limb.\n        let mut hi_bits = (mulout_p.get(0) - mulout_n.get(0) + (borrow_flags.get(0) * borrow_shift)) * downshift;\n        for i in 1..(N + N - 2) {\n            // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n            // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n            //     * downshift;\n            mulout_p.add_assign(i, hi_bits);\n\n            // determine whether negative limb values are greater than positive limb values\n            let underflow: Field = mulout_p.get(i).lt(mulout_n.get(i) + (borrow_flags.get(i - 1) * borrow_carry)) as Field;\n            borrow_flags.set(i, underflow);\n\n            hi_bits = (mulout_p.get(i) - mulout_n.get(i) + (borrow_flags.get(i) * borrow_shift)\n                - (borrow_flags.get(i - 1) * borrow_carry)) * downshift;\n        }\n\n        let mut q = BigNum::from_array(quotient);\n        let mut r = BigNum::from_array(remainder);\n        (q, r, borrow_flags)\n    }\n\n    unconstrained fn __udiv_mod_impl(_: Self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> (BigNum<N, Params>, BigNum<N, Params>) {\n\n\n        let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n        let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator.limbs);\n       \n        let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor.limbs);\n        let b = divisor_u60;\n\n        let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n        let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n        divisor_u60 = divisor_u60.shl(bit_difference);\n        accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n        if (divisor_u60.gte(remainder_u60 + U60Repr::one()))\n        {\n            divisor_u60 .shr1();\n            accumulator_u60.shr1();\n        }\n        for _ in 0..(N * 120) {\n            if (remainder_u60.gte(b) == false)\n            {\n                break;\n            }\n\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (remainder_u60.gte(divisor_u60)) {\n                remainder_u60 -= divisor_u60;\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient_u60 = quotient_u60 + accumulator_u60;\n            }\n            divisor_u60.shr1();// >>= 1;\n            accumulator_u60.shr1();//  >>= 1;\n        }\n\n        (BigNum::from_array(U60Repr::into(quotient_u60)), BigNum::from_array(U60Repr::into(remainder_u60)))\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n\nunconstrained fn __barrett_reduction<let N: u32>(\n    x: ArrayX<Field, N, 2>,\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>\n) -> ([Field; N], [Field; N]) {\n    let mut mulout: ArrayX<Field, N, 3>  = ArrayX { segments: [[0; N]; 3] };\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout.add_assign(i + j, x.get(i) * redc_param[j]);\n        }\n    }\n    mulout = mulout.__normalize_limbs(3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n    let mut quotient_u60 = mulout_u60.shr((k + k));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient: ArrayX<Field, N, 2> = quotient_u60.into_arrayX();\n\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: ArrayX<Field, N, 2>  = ArrayX { segments: [[0; N]; 2] };\n    let mut quotient_mul_modulus_normalized: ArrayX<Field, N, 2>  = ArrayX { segments: [[0; N]; 2] };\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus.add_assign(i + j, partial_quotient.get(i) * modulus[j]);\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus.get(i));\n        quotient_mul_modulus_normalized.set(i, lo);\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus.add_assign(i + 1, hi);\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    let x_u60 : U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n","path":"/home/hdvanegasm/nargo/github.com/noir-lang/noir-bignumv0.3.0/src/runtime_bignum.nr"},"101":{"source":"use dep::bignum::BigNum;\nuse dep::bignum::fields::U256::{U256Params, U256_Instance};\nuse dep::bignum::fields::U384::{U384_Params, U384_Instance};\nuse dep::bignum::fields::U4096::{U4096Params, U4096_Instance};\nuse dep::bignum::fields::U1024::{U1024Params, U1024_Instance};\nuse dep::bignum::fields::U2048::{U2048Params, U2048_Instance};\nuse dep::bignum::runtime_bignum::{BigNumParamsTrait as RuntimeBigNumParamsTrait, BigNumInstance};\nuse dep::bignum::BigNumParamsTrait;\nuse crate::params::N_ITERATIONS;\n\nfn benchmark_add<let N: u64, Params>(\n    x: Field,\n    y: Field,\n    instance: BigNumInstance<N, Params>\n) where Params: RuntimeBigNumParamsTrait<N> + BigNumParamsTrait<N> {\n    let mut a_bn: BigNum<N, Params> = instance.__derive_from_seed([x as u8]);\n    let mut b_bn: BigNum<N, Params> = instance.__derive_from_seed([y as u8]);\n\n    for _ in 0..N_ITERATIONS {\n        let c_bn = a_bn + b_bn;\n\n        a_bn = b_bn;\n        b_bn = c_bn;\n    }\n}\n\npub fn benchmark_add_U256(x: Field, y: Field) {\n    benchmark_add(x, y, U256_Instance)\n}\n\npub fn benchmark_add_U384(x: Field, y: Field) {\n    benchmark_add(x, y, U384_Instance)\n}\n\npub fn benchmark_add_U4096(x: Field, y: Field) {\n    benchmark_add(x, y, U4096_Instance)\n}\n\npub fn benchmark_add_U1024(x: Field, y: Field) {\n    benchmark_add(x, y, U1024_Instance)\n}\n\npub fn benchmark_add_U2048(x: Field, y: Field) {\n    benchmark_add(x, y, U2048_Instance)\n}\n","path":"/home/hdvanegasm/Documents/hashcloak/aztec/noir-bigint-bench/lib/src/add.nr"}},"names":["main"]}